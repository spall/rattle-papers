\section{Related work}
\label{sec:related}

Of the build systems in existence, the vast majority can be thought of as \emph{backward build systems} -- they start at the final target, and recursively determine the dependencies required for that target. In contrast, \Rattle can be thought of as a \emph{forward build system} -- the script executes sequentially in the order given by the user.

\subsection{Comparison to forward build systems}

The idea of treating a script as a build system, omitting execution of commands that have not changed, was first pioneered by \Memoize \cite{memoize} then later popularised by \Fabricate \cite{fabricate}. In both cases the build script was written in Python, where cheap logic was specified in Python and commands were run in a traced environment. If a traced command hadn't changed inputs or outputs since it was last run, then it was skipped. Of these two incarnations, \Fabricate came later and offered more features, so we focus on it. \Fabricate uses \texttt{strace} on Linux, and on Windows uses either file access times (which are either disabled or very low resolution on modern Windows installations) or a proprietary \texttt{tracker} program (which is not generally available). Parallelism can be annotated explicitly, but is usually omitted.

These systems did not seem to have much adoption -- in both cases the original sources are no longer available, and knowledge of them survives only as GitHub copies. \Rattle differs from an engineering perspective by the tracing mechanisms available (see \S\ref{sec:tracing}) and the availability of cloud build (see \S\ref{sec:cloud_builds}) -- both of which are likely just a consequence of being developed a decade later. \Rattle extends these systems in a more fundamental way with the notion of hazards, which both allows the detection of bad build scripts, and allows for speculation -- overcoming the main disadvantage of earlier forward build systems. Stated alternatively, \Rattle takes the delightfully simple approach of these build systems, and tries a more sophisticated execution strategy.

Recently there have been three other implementations of forward build systems we are aware of.

\begin{enumerate}
\item \Shake \cite{shake} provides a forward mode implemented in terms of a backwards build system. The approach is similar to the \Fabricate design, offering skipping of repeated commands and explicit parallelism. In addition, \Shake allows caching custom functions as though they were commands, relying on the explicit dependency tracking functions such as \texttt{need} already built into \Shake. The forward mode has been adopted by a few projects, notably a library for generating static websites/blogs. The tracing features in \Rattle are actually provided by \Shake as a library (which in turn builds on \Fsatrace).
\item \Fac \cite{fac} is based on the \Bigbro tracing library. Commands are given in a custom file format as a static list of commands (i.e. no monadic expressive power as per \S\ref{sec:monadic}), but may optionally include a subset of their inputs or outputs. The commands are not given in any order, but the specified inputs/outputs are used to form a dependency order which \Fac uses. If the specified inputs/outputs are insufficient to give a working order, then \Fac will fail but record the \emph{actual} dependencies which will be used next time -- a build with no dependencies can usually be made to work by running \Fac multiple times.
\item \Stroll \cite{stroll} takes a static set of commands, without either a valid sequence or any input/output information, and keeps running commands until they have all succeeded. As a consequence, \Stroll may run the same command multiple times, using tracing to figure out what might have changed to turn a previous failure into a future success. \Stroll also reuses the tracing features of \Shake and \Fsatrace.
\end{enumerate}

There are significantly fewer forward build systems than backwards build systems, but the interesting dimension starting to emerge is how an ordering is specified. The three current alternatives are the user specifies a valid order (\Fabricate and \Rattle), the user specifies partial dependencies which are used to calculate an order (\Fac) or the user specifies no ordering and search is used (\Stroll and some aspects of \Fac).

\subsection{Comparison to backward build systems}
\label{sec:remote_execution}

The design space of backward build systems is discussed in \cite{build_systems_a_la_carte}. In that paper it is notable that forward build systems do not naturally fit into the design space, lacking the features that a build system requires. We feel that omission points to an interesting gap in the landscape of build systems. We think that it is likely forward build systems could be characterised similarly, but that we have yet to develop the necessary variety of forward build systems to do so. There are two dimensions used to classify backward build systems:

\paragraph{Ordering} Looking at the features of \Rattle, the ordering is a sequential list, representing an excessively strict ordering given by the user. The use of speculation is an attempt to weaken that ordering into one that is less linear and more precise.

\paragraph{Rebuild} For rebuilding, \Rattle looks a lot like the constructive trace model -- traces are made, stored in a cloud, and available for future use. The one wrinkle is that a trace may be later invalidated if it turns out a hazard occurred (see \S\ref{sec:choices}). In particular, the correspondence to constructive traces illuminates the consequences of moving to a deep constructive trace model (see \S\ref{sec:forward_hashes}) -- it solves non-determinism at the cost of losing unchanging builds.

\postparagraphs

There are also two interesting features available in some backward build systems that are relevant to \Rattle:

\paragraph{Sandboxing} Some backward build systems (e.g. \Bazel \cite{bazel}) run processes in a sandbox, where access to files which weren't declared as dependencies are blocked -- ensuring dependencies are always sufficient. A consequence is that often it can be harder to write a \Bazel build system, requiring users to declare dependencies like \texttt{gcc} and system headers that are typically ignored. The sandbox doesn't prevent the reverse problem of too many dependencies.

\paragraph{Remote Execution} Some build systems (e.g. \Bazel and \BuildXL \cite{buildxl}) allow running commands on a remote machine, usually with a much higher degree of parallelism than is available on the users machine. If \Rattle was able to leverage remote execution then speculative commands could be used to fill up the cloud cache, and \emph{not} involve local writes to disk, eliminating all speculative hazards -- a very attractive property. Remote execution in \Bazel sends all files alongside the command, but \Rattle doesn't know the files accessed in advance, which makes that model infeasible. Remote execution in \BuildXL sends the files it thinks the command will need, augments the file system to block if additional files are accessed, and sends further requests back to the initial machine -- which would fit nicely with \Rattle.

% This related work isn't relevant, and doesn't say anything interesting. It feels like a forced way of including Pluto.
%
% \paragraph{Fine-grained dependencies} Pluto \cite{erdweg2015sound} is another backward build system that aims to
% provide fine-grained dependencies and optimal incremental rebuilding.  It supports dynamic
% dependencies, allows users to specify how they would like to depend on a file, and track build
% rule definitions so a build will re-run correctly when changed.  Rattle in contrast doesn't need
% to explicitly track whether a build script changes, and because all dependencies are implicitly
% tracked \Rattle does not provide the ability for a build script author to specify how a command
% should depend on any file.

\subsection{Analysis of existing build systems}

We aren't the first to observe that existing build systems often have incorrect dependencies.  \citet{bezemer2017empirical} performed an analysis of the missing dependencies in \Make build scripts, finding over \emph{1.2 million unspecified dependencies} among four projects. To detect missing dependencies, \citet{detecting_incorrect_build_rules} introduced a concept called \emph{build fuzzing}, finding race-conditions and errors in 30 projects. It has also been shown that build maintenance requires as much as a 27\% overhead \cite{build_maintenance}, a substantial proportion of which is devoted to dependency management. Our anecdotes from \S\ref{sec:evaluation} all reinforce these messages.

% SS TODO maybe mention something about a project like node trying to generate dependencies within make;
\subsection{Speculation}

Speculation is used extensively in many other areas of computer science, from processors to distributed systems. If an action is taken before it is known to be required, that can increase performance, but undesired side-effects can occur. Most speculating systems attempt to block the side-effects from happening, or roll them back if they do.

The most common use of speculation in computer science is the CPU -- \citet{swanson_cpu_speculation} found that 93\% of useful CPU instructions were evaluated speculatively. CPUs use hazards to detect incorrect speculation, with similar types of read/write, write/write and write/read hazards \cite{patterson_cpu_design} -- our terminology is inspired by their approaches. For CPUs many solutions to hazards are available, e.g. stalling the pipeline if a hazard is detected in advance or the Tomasulo algorithm \cite{tomasulo}. We also stall the pipeline if we detect potential hazards, although have to do so with incomplete information, unlike a CPU. The Tomasulo algorithm involves writing results into temporary locations and the moving them over afterwards -- use of remote execution (\S\ref{sec:remote_execution}) might be a way to apply similar ideas to build systems.

Safe futures for Java \cite{welc2005safe} handles a similar problem with Java's futures.
% how to compare to safe futures
The goal of this project was to implement futures in Java that always respect the semantics of the
sequential version of the program.  If mutable state is shared between a future and the
code that executes after its invocation, its continuation, the future and the continuation should
execute in a way so that the effect is the same as if the code executed sequentially.
To prevent dependency violations between the future and its continuation, the system does two things. First, all data accesses to shared state are tracked and recorded, and if a dependency violation occurs the offending code is revoked and restarted.  Second, shared state is versioned using a copy-on-write invariant to ensure threads write to their own copies, preventing a future from seeing its continuation's writes.

This approach cannot currently be applied to Rattle because we do not have the same level of control over the reading and writing of files. Although we can track reads and writes, we cannot cause writes to be done to objects local to the executing command.  If in the future a file system or tracing tool that enabled writes to be intercepted and buffered existed, an approach similar to that used by Safe futures for Java could be applied to Rattle.

% talk about thread level speculation;
Thread level speculation is the process of speculatively executing threads while maintaining the same semantics as if they had executed sequentially.  As with Safe future for Java, in thread
level speculation, the writes of a speculative thread are buffered until it is no longer
speculative.  And, a speculative thread must be sure to read the writes of speculative threads
that precede it in the ordering, but not that come after it.  Unlike Rattle, these systems have
control over writes and can actually buffer them.   % pick an appropriatepaper to cite


\begin{comment}
\subsection{Other related work}

The notion of hazards is used extensively in processor design. This is standard terminology.
\end{comment}
