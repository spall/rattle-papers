\section{Conclusion and future work}
\label{sec:conclusion}

In this paper we present \Rattle, a build system that  takes a sequence of actions and treats them as a build script. From the user perspective, they get the benefits of a conventional build system (incrementality, parallelism) but at lower cost (less time thinking about dependencies, only needing to supply a valid ordering). Compared to conventional build systems like \Make,  \Rattle presents a simpler user interface (no dependencies), but a more complex implementation model.

Our evaluation in \S\ref{sec:evaluation} shows that for some popular real-world projects, switching to \Rattle would bring about simplicity and correctness benefits, with negligible performance cost. The two places where builds aren't roughly equivalent to \Make are the initial build (which could be solved with a global shared cache) and when speculation leads to a hazard. There are several approaches to improving speculation, including giving \Rattle a list of commands that should not be speculated (which can be a perfect list for non-monadic builds), or giving \Rattle a subset of commands' inputs/outputs (like \Fac does), or implementing better recovery strategies from speculation errors.

Our evaluation focuses on projects whose build times are measured in seconds or minutes, with only one project in the hours range. It is as yet unclear whether similar benefits could be achieved on larger code bases, and whether the \Rattle approach of ``any valid ordering'' is easy to describe compositionally for large projects.

% But, it does seem clear that existing projects built with \Make seek some form of automatic dependency detection, with most projects using some form of \texttt{gcc} dependency generation manually wired into the build system.

Our next steps are scaling \Rattle and incorporating feedback from actual users.

%% \paragraph{Acknowledgements} We'd like to thank Jorge Acereda and David Roundy for their work on \Fsatrace and \Bigbro respectively.
