\section{Rattle}
\label{sec:rattle}

We want to take a list of commands, and turn it into a build system. To do that, we assume the existence of a \emph{tracing oracle} which can, after a command completes, tell us which files that command read and which files it wrote -- we discuss the implementation and limitations of the tracing oracle in \S\ref{sec:tracing}. In this section we start by describing the most simple system possible, and progressively add features to obtain the benefits of a full build system.

\subsection{Executing commands}

In it's simplest variant, a build script can be a list of shell commands, like in \S\ref{sec:introduction}. To execute such commands correctly, it is sufficient to run each command sequentially in the order they were given. We consider this the reference semantics, and want any optimised/cached implementation to give the same results. For now, we assume commands are deterministic, but discuss how to weaken that assumption in \S\ref{sce:determinism}. We also assume that each command is atomic - it cannot be subdivided into smaller parts.

\subsection{Monadic builds}
\label{sec:monadic}

A build system which can only execute a static list of commands is restricted in its expressive power. Taking the build system from \S\ref{sec:introduction} - it would be better to compile and link \emph{all} \texttt{*.c} files -- not just those listed in the script. A more plausible script might be:

\begin{verbatim}
FILES=$(ls *.c)
for FILE in $FILES; do
    gcc -c $FILE
done
gcc -o main.exe $FILES{/.c/.o/}
\end{verbatim}

\begin{figure}
\begin{verbatim}
import Development.Rattle

main = runRattle $ do
    -- TODO: Convert
    FILES=$(ls *.c)
    for FILE in $FILES; do
        gcc -c $FILE
    done
    gcc -o main.exe $FILES{/.c/.o/}
\end{verbatim}
\caption{A Haskell/\Rattle version of the script from \S\ref{sec:monadic}}
\label{fig:monadic}
\end{figure}

Now we have a curious mixture of build system commands (e.g. \texttt{ls}, \texttt{gcc}), some control logic (e.g. \texttt{for}) and simple manipulation (e.g. changing file extension). The way we cope with this is to consider the build system as a series of commands, where the future commands may depend on the results of previous commands. These are glued together with ``cheap'' functions like the control logic and simple manipulations. We take the approach that the cheap commands are fixed overhead, run on every build, and not cached or parallelised in any way. If any of these cheap manipulations becomes expensive, they can be replaced by a command, which will then be cached and parallelised.

To implement \Rattle we treat the script as a sequence of commands with no observation on which commands are coming next. As a consequence, even if you are using a simple static script, and then manually edit it, the \Rattle build remains correct -- it has no knowledge that you manually edited the script, or if it was instead conditional on something it didn't observe.

\subsection{Skipping unnecessary commands}

When \Rattle runs a command, it records the files it reads and writes, and their hashes at that point. If you subsequently run the same command, and the inputs and outputs haven't changed, it can be skipped. This is mostly true -- you get old but correct values. If you are running \texttt{date} it won't work, and if you are running \texttt{gcc} it will have an old compilation time. But it's good enough.

\subsection{Cloud builds}

If \Rattle matches on the files read, but not on the files written, but a previous run had the same files read/written and cached the written files, you can copy them over. If that store is in a cloud, you end up with cloud build functionality. It's pretty simple.

\subsection{Build consistency}

For a \Make build system to be stable, it must be the case that after a build, a rebuild will not execute any other commands. It's easy to construct examples of sequences of commands that violate this property, for example:

\begin{verbatim}
gcc -c foo.c
echo x >> foo.c
\end{verbatim}

This script compiles \texttt{foo.c}, then appends the character \texttt{x} to \texttt{foo.c}. Each time around, the input to \texttt{gcc} will have changed, necessitating a recompile. We define such a build as \emph{hazardous}, because it violates one of our consistency rules:

\begin{description}
\item[read-write hazard] When one command reads from a file, and a subsequent command writes to that file. On a future build, the first command will have to be rerun.
\item[write-write hazard] When two commands both write to the same file. On a future build, the first will be rerun (it's output has changed), which is likely to then cause the second to be rerun.
\end{description}

We assume that if a single command both reads and writes to the same file (as \texttt{echo x >> foo.c} does), then within that command they were correctly sequenced.

Using the tracing we spot hazards and raise errors if they occur. We proove that a build system with deterministic control logic with no hazards always results in no rebuilds in \S\ref{sec:proof:no_rebuild}. In a build system without hazards there is at most one write to any file, which occurs before any reads of that file. We can therefore prove there are no rebuilds by showing the first command can't rebuild, and proceeding by induction.

\subsection{Parallelism}

Given a script with no hazards when executed sequentially, we can show that any interleaving of those commands that also has no hazards will result in an equivalent output in \S\ref{sec:proof:reorder}. Moreover, any parallel execution without hazards will remain consistent. And even further, if we execute any additional commands that don't cause hazards, they can be shown to have no impact on the rest of the build.

As a consequence of the above, we can do whatever we want.

In many ways we aren't the first to come up with this speculation idea. The CPU in your desktop computer already takes a series of instructions and executes them with pipelining and speculation. We just do the same with build commands.

Rattle is a build system a la fabricate, where instead of describing what you want to build
you just describe how to build it.

The author of a Rattle build script just what and how to run the tools that build their
project, in an order they know is correct.

Rattle then learns while running the script what the true file dependencies are for the build.
So, the build script author cannot get them wrong.

How does Rattle work?

It uses system level tracing to record the files read and written by the commands specified in
the haskell build script.

Rattle records this tracing information for use during subsequent runs.  On subsequent runs
The tracing information informs Rattle of which cmds should safely run in parallel.

\subsection{Speculation}

Maybe this should be earlier.

Because Rattle doesn't know what cmds are in the build script being run, it cannot perform
the same sort of graph traversal Make can to determine which commands to run in order.

Speculation is used instead to achieve parallelism.  If Rattle believes it is safe, it will run
the commands from the previous build in parallel with the current build script.  When a cmd it
ran speculatively is encountered in the build script it won't have to run the command.

If the build script hasn't changed between runs and the file level dependencies of each cmd
haven't changed, then Rattle should have no problems running cmds in parallel.

But what if the build script or file level dependencies have changed?  Then Rattle might
run cmds in an order that doesn't respect their new dependencies.  To deal with this Rattle
has a concept of hazards, because speculation can go wrong.

\subsection{Hazards}

already need to have explained the properties

Read Write hazard
Write Write hazard

ReadWrite hazard occurs when two commands read and write to the same file at the same time
or a command reads from a file before it is written to

WriteWrite hazard occurs when two commands write to the same file during the build.

When a hazard occurs Rattle will terminate, restart, or continue.  If a property violating hazard
occurred Rattle will terminate and alert the build user.  If Rattle speculated a command that
caused a property violation the build will be restarted with no speculation.
If Rattle speculated a read cmd before a write then Rattle can continue and later re-execute the
read command again.


\subsection{Rebuilds}

using hashes to determine if files have changed

only rerun cmds whose dependencies have changed

\subsection{Shared build cache}

Store output files to copy if they are missing but cmd's dependencies haven't changed

Other things Neil mentioned in the Rattle readme...
