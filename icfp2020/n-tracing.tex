\section{Tracing}
\label{sec:tracing}

Can only do files at the end.

We ignore files that are deleted after, they are temporary.

We'd like a more powerful oracle that intercepts each action, but that doesn't exist.

We'd like to know the precise time of each read/write, but we generalise to the time the command was running.

We use either fsatrace or libbigbro. That gives us call hooking on Windows, syscall hooking on Linux or \verb"LD_LIBRARY" preload on Linux.

We don't trace things like file system listings, modtime info etc. It's a little approx as a result.

Rattle fundamentally relies on tracing the files used by system commands, and currently uses the [`fsatrace`](https://github.com/jacereda/fsatrace) program to do so, which must be installed. As a consequence of the design, if `fsatrace` fails, then `rattle` won't work properly. Reasons that `fsatrace` might fail include:

* If you use Go compiled binaries on Linux or Mac then it's unlikely to be traced, see [Issue 24](https://github.com/jacereda/fsatrace/issues/24).
* If you a Mac OS X 1.10 or higher then system binaries that themselves invoke system binaries they won't be traced, unless you disable System Integrity Protection \url{https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html} (which you do at your own risk).
* If you use statically linked binaries on Linux they probably won't be traced.

It is possible to write alternative tracing mechanisms that wouldn't have these limitations, for example:

* [Bigbro](https://github.com/droundy/bigbro/) uses `ptrace` so works for Go binaries and statically linked binaries.
* [traced-fs](https://github.com/jacereda/traced-fs) is an unfinished file system tracer that implements a user file system that would also work for Go binaries and static linking.
* [BuildXL] \url{https://github.com/Microsoft/BuildXL/blob/master/Documentation/Specs/Sandboxing.md#macos-sandboxing} uses a Mac sandbox based on KAuth + TrustedBSD Mandatory Access Control (MAC).
