\section{Related work}
\label{sec:related}

Of the build systems in existence, the vast majority can be thought of as backward build systems - they start at the final target, and recursively determine the dependencies required for that target. In contrast, \Rattle can be thought of as a forward build system -- the script executes sequentially in the order given by the user.

\subsection{Comparison to forward build systems}

The idea of treating a script as a build system, omitting execution of commands that have not changed, was first pioneered by \Memoize \cite{memoize} then later popularised by \Fabricate \cite{fabricate}. In both cases the build script was written in Python, where cheap logic was specified in Python and commands were run in a traced enviroment. If a traced command hadn't changed inputs or outputs since it was last run, then it was skipped. Of these two incarnations, \Fabricate came later and offered more features, so we focus on it. \Fabricate uses \texttt{strace} on Linux, and on Windows uses either file access times (which are either disabled or very low resolution on modern Windows installations) or a proprietory and non-distributable \texttt{tracker} program. Parallelism can be annotated explicitly, but is considered an advanced feature.

These systems did not seem to have much adoption -- in both cases the original sources are no longer available, and knowledge of them survives on GitHub copies. \Rattle differs from an engineering perspective by the tracing mechanisms available (see \S\ref{sec:tracing}) and the use of cloud build (see \S\ref{sec:cloud_builds}) -- both of which are likely just a consequence of being developed a decade later. \Rattle extends these systems in a more fundamental way with the notion of hazards, which both allow the detection of bad build scripts, and allow for speculation -- overcoming the main disadvantage of earlier foward build systems. Stated alternatively, \Rattle takes the delightfully simple approach of these build systems, and tries a more sophisticated execution strategy.

Recently there have been tree other implementations of forward build systems.

\begin{enumerate}
\item \Shake \cite{shake} provides a forward mode implemented in terms of a backwards build system. The approach is similar to the \Fabricate design, offering skipping of repeated commands and explicit parallelism. In addition, \Shake allows caching custom functions as though they were commands, relying on the explicit dependency tracking functions such as \texttt{need} already built into \Shake. The forward mode has been adopted by a few projects, notably a library for generate static websites/blogs. The tracing features in \Rattle are actually provided by \Shake as a library (which in turn builds on \Fsatrace).
\item \Fac \cite{fac} is based on the \Bigbro tracing framework. Commands are given in a custom file format as a static list of commands (i.e. no monadic expressive power as per \S\ref{sec:monadic}), but may optionally include a subset of their inputs or outputs. The commands are not given in any order, but the specified inputs/outputs are used to form a dependency order which \Fac uses. If the specified inputs/outputs are insufficient to give a working order, then \Fac will fail but record the \emph{actual} dependencies which will be used next time -- a build with no dependencies can usually be made to work by running \Fac multiple times.
\item \Stroll \cite{stroll} takes a static set of commands, without either a valid sequence or any input/output information, and keeps running commands until they have all succeeded. As a consequence, \Stroll may run the same command multiple times, using tracing to figure out what might have changed to turn on previous failure into a future success. \Stroll also reuses the tracing features of \Shake and \Fsatrace.
\end{enumerate}

There are significantly fewer forward build systems than backwards build systems, but the interesting dimension starting to emerge is how an ordering is specified. The three current alternatives are the user specifies a valid order (\Fabricate and \Rattle), the user specifies some dependencies which are used to calculate an order (\Fac) or the user specifies no ordering and search is used (\Stroll and some aspects of \Fac).

\subsection{Comparison to backward build systems}

The design space of backward build systems is discussed in \cite{build_systems_a_la_carte}. In that paper it is notable that \Fabricate does not naturally fit into the design space, lacking the features that a build system requires. We feel that points to an interesting gap in the landscape of build systems. We think that it is likely forward build systems could be characterised similarly, but that we have yet to develop the necessary variety of forward build systems to do so. There are two dimensions in the paper:

\paragraph{Ordering} Looking at the features of \Rattle, the ordering is an excessively strict ordering given by the user. The use of speculation is an attempt to weaken that ordering into one that is more refined.

\paragraph{Rebuild} For rebuilding \Rattle looks a lot like the constructive trace model -- traces are made, stored in a cloud, and accessible for future use. The one wrinkle is that a trace may be later invalidated, if it turns out a hazard occurred (see \S\ref{sec:choices}). In particular, the correspondence to constructive traces illuminates the consequences of moving to a deep constructive trace model (see \S\ref{sec:forward_hashes}) -- it solves non-determinism at the cost of losing unchanging builds.

\postparagraphs

Some backward build systems (e.g. \Bazel \cite{bazel}) have sandboxing to ensure all dependencies are declared, and otherwise cause commands to fail, ensuring that dependencies are sufficient. A consequence is that often it can be significantly harder to write a \Bazel build system, declaring dependencies like \texttt{gcc} and system headers that are usually ignored in other build systems. The sandbox doesn't prevent the reverse problem of too many dependencies.

Remote execution is when commands are run on a remote machine, usually with a much higher degree of parallelism than is available on the users machine. Remote execution would offer several benefits for \Rattle. Firstly, the command can execute remotely, or in a sandboxed manner - ensuring all writes do \emph{not} end up on the file system, but are recorded to the cloud cache. In such a mode we are filling up the coud cache speculative, with the hope that when the future command does arrive it can be satisfied from the cache. However, running remotely requires syncronising the files across, or using a sycronise on demand approach, such as that described by Microsoft \cite{}. Running with a sandbox which intercepts writes is not an easily available cross-platform feature, so we have not explored it further.

\subsection{Analysis of existing build systems}

We aren't the first to observe that existing build systems often have the wrong dependencies \cite{detecting_incorrect_build_rules}. We are also aware that build maintenance requires a lot of effort \cite{build_maintenance}. Our anecdotes from \S\ref{sec:evaluation} reinforce these messages.

\begin{comment}
\subsection{Other related work}

The notion of hazards is used extensively in processor design. This is standard terminology.
\end{comment}
