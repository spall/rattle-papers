\section{Evaluation}
\label{sec:evaluation}

In this section we evaluate the design from \S\ref{sec:design}, specifically our implemenation as per \S\ref{sec:implementation}. We show how the implementation performs on the example from \S\ref{sec:introduction} in \S\ref{sec:eval:introduction}, on microbenchmarks in \S\ref{sec:eval:overhead}, and then on real projects that currently use \Make -- namely Redis (\S\ref{sec:eval:redis}), FSATrace (\S\ref{sec:eval:fsatrace}), Vim (\S\ref{sec:eval:vim}) and Node (\S\ref{sec:eval:node}). For larger projects we look at both whether the dependencies are correct and the performance of \Rattle -- is \Rattle a viable alternative to the existing \Make scripts.

\subsection{Validating the claims from \S\ref{sec:introduction}}
\label{sec:eval:introduction}

In \S\ref{sec:introduction} we claimed that the following build script is ``just as good'' as a proper \Make script.

\begin{verbatim}
gcc -c main.c
gcc -c util.c
gcc -o main.exe main.o util.o
\end{verbatim}

There are two axes on which to measure ``just as good'' -- correctness and performance. Performance can be further broken down into how much rebuilds, how much parallelism can be acheived, and overhead.

\paragraph{Correctness} \Rattle is correct, in that the reference semantics is running all the commands, and as we have shown in \S\ref{sec:design} and \S\ref{sec:proof}, \Rattle obeys that semantics. In contrast, the \Make version may have missing dependencies which causes it not to rebuild. Examples of failure to rebuild include both if \texttt{gcc} changes, one of the system headers used by \texttt{gcc} or any headers included but not listed in the \Make script.

\paragraph{Rebuilding too much} \Rattle only rebuilds a command if some of the inputs to a command have changed. It is possible that a command only depends on a subset of those inputs, but at the level of abstraction \Rattle works, it never rebuilds too much. As a matter of implementation, to implement cloud builders as per \ref{sec:cloud_builds}, \Rattle uses hashes of the file contents. In contrast, \Make uses the modification time, so if a file is modified, but it's contents do not change, \Make will rebuild but \Rattle will not (e.g. using \texttt{touch}). It would be possible for \Make to use modification times, if it chose to store additional metadata not in the file system.

\paragraph{Parallelism} The script from \S\ref{sec:introduction} has three commands, the first two of which can run in parallel, the the third of which must wait for the first two to finish. \Make is given all this information by dependencies, so will always acheive as much parallelism as is available. In constrast, \Rattle has no such knowledge, so has to recover the parallelism by speculation, as per \ref{sec:speculation}. During the first execution, \Rattle has no knowledge about even which commands are coming next (as described in \S\ref{sec:monadic}), so has no choice but to execute each command serially, with less parallelism than \Make. In subsequent executions \Rattle will use speculation to always speculate on the second command (as it never has a hazard with the first), but never speculate on the third until the first two have finished (as they are known to conflict). Interestingly, sometimes \Rattle executes the third command (because it got to that point in the script), and sometimes it speculates it (because the previous two have finished) -- it is a race condition where both alternatives are equivalent. So \Rattle has less parallelism on the first execution, but using the cloud features, that can be reduced to the first execution \emph{ever}, rather than the first execution for a given user.

\paragraph{Overhead} The overhead inherent in \Rattle is greater than that of \Make as it hashes files, traces command execution, computes potential hazards to figure out speculation and writes to a shared cloud store. To measure the overhead, and prove the other claims in this section, we created a very simple pair of \texttt{main.c} and \texttt{util.c} files where \texttt{main.c} calls \texttt{printf} using a string computed by a function in \texttt{util.c}. We then measured the time to do 1) an initial build; 2) a rebuild when nothing had changed; 3) a rebuild with whitespace changes to \texttt{main.c}; 4) a rebuild with meaningfully changes to \texttt{main.c}; 5) a rebuild with meaingfully changes to both C files. We did all the above with 1, 2 and 3 threads, on Linux. To check speculation was happening, we modified \texttt{gcc} to sleep for 1 second before starting. The numbers are:

% RAW RESULTS
% $ rattle-benchmark intro
%   make   -j1: 3.35s 0.00s 2.19s 2.19s 3.28s
%   rattle -j1: 3.28s 0.00s 1.12s 2.16s 3.29s
%   make   -j2: 2.18s 0.00s 2.19s 2.23s 2.22s
%   rattle -j2: 3.28s 0.00s 1.12s 2.21s 2.20s
%   make   -j3: 2.20s 0.00s 2.19s 2.19s 2.19s
%   rattle -j3: 3.36s 0.00s 1.10s 2.22s 2.20s
%   make   -j4: 2.20s 0.00s 2.19s 2.18s 2.19s
%   rattle -j4: 3.28s 0.00s 1.14s 2.21s 2.20s

\vspace{3mm}
\begin{tabular}{l|r|r||r|r||r|r}
Number of threads & \multicolumn{2}{c||}1 & \multicolumn{2}{c||}2 & \multicolumn{2}{c}3 \\
Tool & \Make & \Rattle & \Make & \Rattle & \Make & \Rattle \\
\hline
Initial build & 3.35s & 3.28s & 2.18s & 3.28s & 2.20s & 3.36s \\
Nothing changed & 0.00s & 0.00s & 0.00s & 0.00s & 0.00s & 0.00s \\
\texttt{main.c} changed whitespace & 2.19s & 1.12s & 2.19s & 1.12s & 2.19s & 1.10s \\
\texttt{main.c} changed meaingfully & 2.19s & 2.16s & 2.23s & 2.21s & 2.19s & 2.22s \\
Both C files changed meaningfully & 3.28s & 3.29s & 2.22s & 2.20s & 2.19s & 2.20s \\
\end{tabular}
\vspace{3mm}

As expected, we see that in the initial build \Rattle doesn't exhibit parallelism, but \Make can. In constrast, \Rattle can benefit when a file changes in whitespace only and the resulting object file doesn't change, while \Make can't. We see 3 threads has no change over 2 threads, as this build contains no more parallelism opportunities. Comparing the non-sleep portion of the build, \Make and \Rattle are quite evenly matched, typically within a few milliseconds, showing low overheads -- we focus on the overheads in the next section.

\subsection{Measuring overhead}
\label{sec:eval:overhead}

In order to determine what overhead \Rattle and \Fsatrace introduce we took the latest version of \Fsatrace\footnote{Git commit 41fbba17da580f81ababb32ec7e6e5fd49f11473} and ran \texttt{make -j1}, capturing the commands that were executed, and reran those commands trying to isolate the overheads introduced by each part of \Rattle. The \Rattle command execution uses the command execution from \Shake \cite{shake} as a library, which in turn builds on the command execution from the Haskell \texttt{process} library. Therefore, we ran the commands in a clean build directory in 7 different ways:

\begin{enumerate}
\item Using \texttt{make -j1}
\item Using \texttt{System.Process} from the Haskell \texttt{process} library.
\item Using \texttt{cmd} from the Haskell \texttt{shake} library \cite{shake}, which builds on top of the \texttt{process} library.
\item Using \texttt{cmd} from \texttt{shake}, but wrapping the command with \Fsatrace.
\item Using \texttt{cmd} from \texttt{shake} with the \texttt{Traced} setting, which runs \Fsatrace and collects the result from a temporary directory.
\item Using \Rattle with no speculation or parallelism, and not storing any results to shared storage.
\item Using \Rattle with all features turned on, including shared storage.
\end{enumerate}

We ran all sets of commands five times, and took the average of the three fastest, on both Windows and Linux. On Windows \Fsatrace compiles in 25 commands (21 compiles, 4 links). On Linux \Fsatrace compiles in 9 commands (7 compiles, 2 links). On Linux the current build system produces write-write hazards, because it compiles some files (e.g. \texttt{shm.c}) twice, once with \texttt{-fPIC} (position independent code), and once without. However, both times it passes \texttt{-MMD} to cause \texttt{gcc} to produce \texttt{shm.d} which is used for dependencies -- we removed the \texttt{-MMD} flag as it doesn't impact the above benchmark.

% RAW RESULTS (final number is avg of fastest 3, to ignore swapping etc)
% $ rattle-benchmark micro
%   WINDOWS (with Windows Defender)
%     make: 13.14s 10.47s 11.04s 11.67s 11.86s = 11.06s
%     System.Process: 12.28s 12.41s 12.90s 13.07s 13.24s = 12.53s
%     shake.cmd: 13.59s 13.83s 13.88s 13.99s 14.08s = 13.77s
%     shake.cmd fsatrace: 16.54s 17.06s 16.55s 16.41s 16.39s = 16.45s
%     shake.cmd traced: 16.52s 16.42s 16.84s 16.69s 16.70s = 16.54s
%     rattle: 20.70s 18.51s 18.93s 18.50s 18.51s = 18.51s
%     rattle share: 18.94s 19.10s 18.74s 18.74s 18.63s = 18.70s
%   WINDOWS (no Windows Defeneder)
%     make: 12.31s 9.73s 9.98s 14.97s 10.16s = 9.96s
%     System.Process: 10.20s 10.25s 10.32s 10.40s 10.44s = 10.26s
%     shake.cmd: 10.53s 10.68s 10.62s 10.59s 10.70s = 10.58s
%     shake.cmd fsatrace: 12.68s 12.58s 12.85s 12.72s 12.80s = 12.66s
%     shake.cmd traced: 13.31s 12.99s 12.86s 13.90s 16.26s = 13.06s
%     rattle: 16.59s 14.51s 14.48s 14.82s 14.30s = 14.43s
%     rattle share: 14.56s 14.48s 14.62s 14.62s 14.56s = 14.53s
%   LINUX
%     make: 1.26s 1.22s 1.19s 1.23s 1.17s = 1.19s
%     System.Process: 1.19s 1.19s 1.22s 1.24s 1.16s = 1.18s
%     shake.cmd: 1.20s 1.18s 1.17s 1.21s 1.18s = 1.17s
%     shake.cmd fsatrace: 1.26s 1.20s 1.26s 1.25s 1.25s = 1.23s
%     shake.cmd traced: 1.25s 1.23s 1.27s 1.21s 1.23s = 1.23s
%     rattle: 1.50s 1.29s 1.25s 1.25s 1.25s = 1.25s
%     rattle share: 1.31s 1.31s 1.31s 1.26s 1.24s = 1.27s

\vspace{3mm}
\begin{tabular}{l|rrr|rrr}
Commands & \multicolumn{3}{c|}{Windows} & \multicolumn{3}{c}{Linux} \\
\hline
Make & 9.96s & 100\% &  & 1.19s & 100\% & \\
process & 10.26s & 103\% & +3\% & 1.18s & 99\% & -1\% \\
\Shake & 10.58s & 106\% & +3\% & 1.17s & 98\% & -1\% \\
\Shake + \Fsatrace & 12.66s & 127\% & +21\% & 1.23s & 103\% & +5\% \\
\Shake + \texttt{Traced} & 13.06s & 131\% & +4\% & 1.23s & 103\% & +0\% \\
\Rattle & 14.43s & 145\% & +14\% & 1.25s & 105\% & +2\% \\
\Rattle + everything & 14.53s & 146\% & +1\% & 1.27s & 107\% & +2\% \\
\end{tabular}
\vspace{3mm}

Both Windows and Linux have three columns -- the time taken (average of five runs), that time as a percentage of the \Make run, and the delta from the row above. The results are significantly different between platforms:

\paragraph{Windows} On Windows, we see that the total overhead of \Rattle makes the execution 46\% slower. Of the parts, 21\% of the slowdown is from \Fsatrace, with the next greatest overhead being from \Rattle. Of the \Rattle overhead, one of the things that is necessarily slower on Windows is canonicalising filepaths. Using the default NTFS file system, Windows considers paths to be case insensitive. As a result, we observe paths like \verb"C:\windows\system32\KERNELBASE.dll", which in actual fact are on disk called \verb"C:\Windows\System32\KernelBase.dll", but can also be accessed by names such as \verb"C:\Windows\System32\KERNEL~1.DLL". Unfortunately, Windows also supports case sensitive disks, so it's also not sufficient to just lowercase them. Furthermore, disabling the anti-virus (Windows Defeneder) has a significant impact on the result -- these results are with the anti-virus disabled.

\paragraph{Linux} In contrast, on Linux, the total overhead is only 7\%, of which nearly all (5\%) comes from the tracing.

\postparagrahs

These results show that tracing has minor but not insignificant on Linux, whereas on Windows can be a substantial performance reduction. As a consequence, we focus on the results under Linux.

\subsection{\Fsatrace}
\label{sec:eval:fsatrace}

To measure \Fsatrace between \Make and \Rattle we took the commands we extracted for \S\ref{sec:eval:overhead} and ran the build script at each successive step. The performance results at various levels of threading were:

\begin{tikzpicture}
\begin{axis}[
  title=Compile time in seconds,
  width=\textwidth,
  height=7cm,
  xlabel={Time at each successive commit},
  ylabel={Seconds},
  ymin=0,
  xmin=0,
]
\addplot table [x expr=\coordindex, y=make1] {data/fsatrace.dat}; 	\addlegendentry{\Make -j1}
\addplot table [x expr=\coordindex, y=make2] {data/fsatrace.dat}; 	\addlegendentry{\Make -j2}
\addplot table [x expr=\coordindex, y=make3] {data/fsatrace.dat}; 	\addlegendentry{\Make -j3}
\addplot table [x expr=\coordindex, y=make4] {data/fsatrace.dat}; 	\addlegendentry{\Make -j4}
\addplot table [x expr=\coordindex, y=rattle1] {data/fsatrace.dat}; 	\addlegendentry{\Rattle -j1}
\addplot table [x expr=\coordindex, y=rattle2] {data/fsatrace.dat}; 	\addlegendentry{\Rattle -j2}
\addplot table [x expr=\coordindex, y=rattle3] {data/fsatrace.dat}; 	\addlegendentry{\Rattle -j3}
\addplot table [x expr=\coordindex, y=rattle4] {data/fsatrace.dat}; 	\addlegendentry{\Rattle -j4}
\end{axis}
\end{tikzpicture}

We ran it for 100 commits, but hid any commands where all variants where < 0.02s. As we can see, the first build is always > 1s for \Rattle, but \Make is able to optimise it as low as 0.33s with 4 threads. This is a consequence of \Rattle not knowing the parallelism from then on. Otherwise, \Rattle and \Make are competitive -- users would struggle to see the difference. The one commit that does show some variation is commit 2, where \Make at 1 thread matches all the \Rattle builds, but \Make at 2 threads or above goes slightly faster. The cause is a speculation leading to a write-write hazard. Concretely, the command for link \texttt{fsatrace.so} has changed to include a new file \texttt{proc.o}. \Rattle starts speculating on the old link, then gets the command for the new line -- they both write to \texttt{fsatrace.so}, leading to a hazard, and causing \Rattle to restart without speculation. Had the real linker arrived first then an unknown command would have been executing and we wouldn't have run it.

% WriteWriteHazard /tmp/extra-dir-39079319872788/fsatrace.so Cmd [EchoStderr False] ["cc","-shared","src/unix/fsatraceso.os","src/emit.os","src/unix/shm.os","-o","fsatrace.so","-ldl","-lrt"] Cmd [EchoStderr False] ["cc","-shared","src/unix/fsatraceso.os","src/emit.os","src/unix/shm.os","src/unix/proc.os","-o","fsatrace.so","-ldl","-lrt"] Restartable

\subsection{Redis}
\label{sec:eval:redis}

\begin{tikzpicture}
\begin{axis}[
  title=Compile time in seconds,
  width=\textwidth,
  height=7cm,
  xlabel={Time at each successive commit},
  ylabel={Seconds},
  ymin=0,
  xmin=0,
]
\addplot table [x expr=\coordindex, y=make1] {data/redis.dat}; 	\addlegendentry{\Make -j1}
\addplot table [x expr=\coordindex, y=make4] {data/redis.dat}; 	\addlegendentry{\Make -j4}
\addplot table [x expr=\coordindex, y=rattle1] {data/redis.dat}; 	\addlegendentry{\Rattle -j1}
\addplot table [x expr=\coordindex, y=rattle4] {data/redis.dat}; 	\addlegendentry{\Rattle -j4}
\addplot table [x expr=\coordindex, y=rattle4_noshared] {data/redis.dat}; 	\addlegendentry{\Rattle -j4 (no shared)}
\end{axis}
\end{tikzpicture}

We turn off sharing, because that makes us go faster. The Redis project is structured as recursive \Make, which is known to be problematic \cite{miller:recursive_make}.


\begin{comment}
% I reimplemented Stack in Rattle. Not sure it's useful given how much other evaluation stuff we have.
\subsection{Reimplementing Stack}

\Rattle assumes that each command is atomic - it cannot be subdivided into smaller parts. If a command is secretly two independent commands then they should usually be expressed as such so they can be individually skipped.

Compound commands: Sometimes a command will produce something that is user specific (not great for caching), but the next step will remove the user specificity (good for caching). To fix that we allow compound commands, by conjoining two commands with \texttt{\&\&}. Sometimes the sole purpose of the second command can be to strip machine-unique data from the first command.

As another example, the GHC package database has additional entries added every time a package is installed, making the output a consequence of the original file\footnote{As a consequence many build systems, including \Bazel and \Rattle, use multiple package databases with only one entry per database}.

and some memoisation operations (\texttt{memo})
\end{comment}

\subsection{vim}
\label{sec:eval:vim}

Vim is a popular text editor whose source code can be found on \href{https://github.com/vim/vim}{github}.  The majority of the source code is Vim script and C, and it is built with Make.  To build Make on a Unix based system one can merely call \Make from the top-level project directory.  To compare the original \Make based build to a new \Rattle build, we generated Vim over a series of commits checked-out from github with both the original build system and the adapted \Rattle build.  The \Rattle build script was created by recording every command executed by the original build, except for those invoking \Make.  Additionally, some commands which may have been separate shell commands in the original build were combined to create one command if they caused either \emph{read-write} or \emph{write-write} hazards.  A \Rattle build script was generated for each commit where the orginal build system changed or files were added to or removed from the project.  This was necessary since the \Rattle build was created from a literal list of hard-coded shell commands rather than the ideal Haskell program with variables.

% SS todo add list of the commits

Comparing building Vim \cite{} with \Make and with \Rattle for commits \emph{21109272f} to \emph{7cc96923c}.  For two commits \Make and \Rattle did noticeably different work; note, both of these commits were build incrementally, \emph{21109272f} was built from scratch by both build systems and all subsequent commits were built incrementally.

\begin{description}
\item[\emph{e258368b4}]
  Looking at the git commit, only two files changed: \emph{osdef.sh} and \emph{version.c}.  Rattle re-ran \emph{osdef.sh}, which generates \emph{osdef.h}.  Rattle also rebuilt \emph{version.o}, which depends on \emph{version.c}
  The header file \emph{osdef.h} did not change when it was re-created, which \Rattle detected since it uses hashes to determine when files have changed.  \Make, which uses timestamps, did not detect this and built an additional 109 object files because they depend on \emph{osdef.h}

  Rattle avoided rebuilding 109 object files by using a more accurate standard for detecting changes in dependencies.

\item[\emph{a259d8d30}]
  The files changed by the commit are: \emph{src/evalfunc.c}, \emph{src/proto/evalfunc.pro},
  \emph{src/testdir/test\_vim9\_script.vim}, \emph{src/userfunc.c}, \emph{src/version.c}, and
  \emph{src/vim9compile.c}.
  \Rattle rebuilt the following object files, because \emph{evalfunc.pro} changed.
  \begin{description}
  \item[Object files rebuilt which did \emph{not change}.] \Rattle rebuilt 32 object files because \emph{evalfunc.pro} changed, but the object files did not change when rebuilt.
    %arabic.o, blob.o, blowfish.o, crypto.o, dict.o, evalbuffer.o, evalwindow.o, ex\_cmds2.o, ex\_eval.o, hashtab.o, list.o, map.o, move.o, pathdef.o, popupmenu.o, session.o, sign.o, sound.o,
    %undo.o, vim9execute.o, vim9script.o, bufwrite.o, gui\_beval.o, xdiffi.o, xemit.o, xprepare.o, xutils.o, xhistogram.o, xpatience.o, charset.o, json.o, memfile.o.
  \item[Object files rebuilt which did \emph{change}.] \Rattle rebuilt an additional 78 object files because \emph{evalfunc.pro} changed, whose object files did change after being rebuilt.
    4 of these object files corresponding c files had changed, also causing them to rebuild.

  % arglist.o, autocmd.o, beval.o, buffer.o, change.o, cindent.o, cmdexpand.o, cmdhist.o, crypt_zip.o, debugger.o, diff.o, digraph.o, drawline.o, drawscreen.o, edit.o, eval.o
  % evalfunc.o (evalfunc.c had also changed), evalvars.o, ex\_cmds.o, ex\_docmd.o, ex\_getln.o, fileio.o, filepath.o, findfile.o, fold.o, getchar.o, hardcopy.o, highlight.o, if\_cscope.o
  % if\_xcmdsrv.o, indent.o, insexpand.o, mark.o, mbyte.o, memline.o, menu.o, misc1.o, misc2.o, mouse.o, normal.o, ops.o, option.o, optionstr.o, os\_unix.o, popupwin.o
  % profiler.o, pty.o, quickfix.o, regexp.o, register.o, screen.o, scriptfile.o, search.o, sha256.o, spell.o, spellfile.o, spellsuggest.o, syntax.o, tag.o, term.o, terminal.o
  % testing.o, textprop.o, ui.o, usercmd.o, userfunc.o (userfunc.c also changed), vim9compile.o (vim9compile.c alos changed) , viminfo.o, window.o, gui.o, gui\_gtk.o,
    % gui\_gtk\_x11.o, gui\_gtk\_f.o, netbeans.o, channel.o, main.o, message.o version.o (version.c also changed)
  \end{description}
\end{description}

\Make rebuilt 4 object files, the ones whose corresponding c files had changed.  It didn't rebuild the other object files rebuilt by \Rattle because the Makefile does not state that these object files
depend on \emph{src/proto/evalfunc.pro}.

% SS todo add timing data

\subsection{node}
\label{sec:eval:node}

% Brief into to the project
Node.js is a JavaScript runtime built on Chrome's V8 Javascript engine and can be found on \href{``https://github.com/nodejs/node''}{github}.  The project is largely written in JavaScript, C++, Python, and C, and is built using Make and a meta-build tool called \emph{Generate Your Projects (GYP)}.  To build Node.js from source, a user first runs \emph{./configure} which runs a python script that configures the build and runs GYP.  GYP generates the majority of the Makefiles used to build the project.

GYP takes a series of \emph{.gyp} files and produces the project build from those.  It puts all generated files in the project's \emph{out} directory and generates a separate \emph{*.mk} Makefile for each target, all of which are included by the top-level Makefile.  The generated top-level Makefile includes a \emph{do\_cmd} function which first checks if a command changed since the last time it was run, and if it has runs the command.  Additionally, it writes the command run to a generated dependency file, and if the command run was a \emph{g++} command that produced a file with dependencies, the dependencies in that file are cleaned up and written to the generated dependency file.

These dependency files are included in the top-level \emph{out/Makefile}, presumably so on future runs Make can consider the recorded dependencies of these object files as well as check whether the command has changed since it was previously run.  Most of these targets include the dependency \emph{FORCE\_DO\_CMD} which is an empty phony target and serves the purpose of forcing the build to check everytime whether the command has changed since it was previously run. Each time a command is re-run, these dependency files are re-generated.

% Explain the makefile insanity and all of this dependency stuff they do
% Still trying to make coherent since of what this gyp is doing, so here is my current understanding

The build both seems to be using a form of tracing to keep track of accurate dependencies as well as tracking whether or not the build itself has changed.  \Rattle would make it unnecessary for the build to explicitely do this, since it internally traces and tracks the depencencies of all commands run, and doesn't need to worry about when a build changes.

% The generator/make.py

% what is this
% # Helper that is non-empty when a prerequisite changes.
% # Normally make does this implicitly, but we force rules to always run
% # so we can check their command lines.
% #   $? -- new prerequisites
% #   $| -- order-only dependencies
% prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))

% # do_cmd: run a command via the above cmd_foo names, if necessary.
% # Should always run for a given target to handle command-line changes.

% Explain the intermediate files and how on a rebuild with no changes stuff still happens

When building certain targets, \emph{.intermediate} files are created and at the end of the build deleted.  These \emph{.intermediate} commands appear to be for doing code generation.  So, the generated files depend on the \emph{.intermediate} target which runs the code generator.  As with the object file targets mentioned, a \emph{.intermediate.d} dependency file is generated for the \emph{.intermediate} target.  This dependency file contains the \emph{.intermediate} code generation command run, so the build can check whether the command changed since it was last run.

These \emph{.intermediate} files are specified as prereqs of the special \Make target {.INTERMEDIATE}, which means that when one does not exist \Make won't bother updating it unless one of its prerequisites has changed.  Because these \emph{.intermediate} targets have \emph{DO\_/FORCE\_CMD} as a prereq they always run.  This would enable the build to check if the command changed since it was last run, but this only works if the Makefile includes the dependency file storing that information.  The dependency files of these \emph{.intermediate} targets, which run everytime, are not included in the Makefile.  Because of this the Makefile thinks the command has never run before, causing them to run everytime.  Even if the Makefile is modified to include the dependency files of these \emph{.intermediate} targets, the targets still execute the recipe which does the file generation even though the command has not changed. % SS comment on this further when I fully understand why the commands are registering as changed...

  % Other things like parallelism and rattle rebuilding less

It appears the authors of this build are attempting to keep track of accurate dependencies by recording them every time a command runs, they are also tracking the build by recording every command run and checking whether a command or its prerequisites have changed when deciding whether to run it.  The scheme to accomplish this is in my opinion quite complicated and confusing and relies on various hacks to work around \Make and the fact that this isn't a full-fledged programming language.  \Rattle accomplishes both of these things the build authors are trying to accomplish with \Make without forcing them to work so hard.

To compare the \Make based build to a \Rattle version, we built Node.js over a series of commits checked-out from github with both the original build system and the adapted \Rattle build.  The \Rattle build was created by recording every command executed by the original build, except for the commands creating dependency files and those invoking \Make.  A new such \Rattle build script was generated for any commit where the original build system changed or files were added to or removed from the project.
% data


% SS add the differences in commits
% 1. make list of commits run

% in order from latest to oldest.
% d80c40047b 0fe810168b 22724894c9 ab9e89439e cb210110e9 d10927b687
% 023ecbccc8 be6596352b [54c1a09202] 470511ae78 25c3f7c61a 13fe56bbbb
% [43fb6ffef7] a171314003 dd4c62eabe abe6a2e3d1 9225939528 d4c81be4a0
% 38aa31554c 1d9511127c d227d22bd9 5cf789e554 d65e6a5017 24e81d7c5a
% 2cd9892425 [64161f2a86] 0f8941962d 2170259940 32f63fcf0e 2462a2c5d7
% b851d7b986 70c32a6d19 3d456b1868 f2ec64fbcf 59a1981a22 [7b7e7bd185]
% 78743f8e39 a5d4a397d6
% [] indicate a commit where build appears to have changed. so need new rattle build too


% So, pretty much everything needs to be re-run. awesome.

% 5. Record here
% 6. Run on tank? with various threads; ask sam





% Comment from the Makefile
%# .buildstamp needs $(NODE_EXE) but cannot depend on it
%# directly because it calls make recursively.  The parent make cannot know
%# if the subprocess touched anything so it pessimistically assumes that
%# .buildstamp is out of date and need a rebuild.
%# Just goes to show that recursive make really is harmful...
%# TODO(bnoordhuis) Force rebuild after gyp update.
