\section{Evaluation}
\label{sec:evaluation}

\subsection{Validating the claims from \S\ref{sec:introduction}}

In \S\ref{sec:introduction} we claimed that the following build script is ``just as good'' as a proper \Make script.

\begin{verbatim}
gcc -c main.c
gcc -c util.c
gcc -o main.exe main.o util.o
\end{verbatim}

There are two axes on which to measure ``just as good'' -- correctness and performance. Performance can be further broken down into how much rebuilds, how much parallelism can be acheived and overhead.

\paragraph{Correctness} \Rattle is correct, in that the reference semantics is running all the commands, and as we have shown in \S\ref{sec:design} and \S\ref{sec:proof}, \Rattle obeys that semantics. In contrast, the \Make version may have missing dependencies which causes it not to rebuild. Examples of failure to rebuild include both if \texttt{gcc} changes, one of the system headers used by \texttt{gcc} or any headers included but not listed in the \Make script.

\paragraph{Rebuilding too much} \Rattle never rebuilds too much, as if none of the inputs to a command have changed, then nothing rebuilds. As a matter of implementation, to implement cloud builders as per \ref{sec:cloud_builds}, \Rattle uses hashes of the file contents. In contrast, \Make uses the modification time, so if a file is resaved, but it's contents do not change, \Make will rebuild but \Rattle will not. It would be possible for \Make to use modification times, if it chose to store additional metadata not in the file system.

\paragraph{Parallelism} The script from \S\ref{sec:introduction} has three commands, the first two of which can run in parallel, the the third of which must wait for the first two to finish. \Make is given all this information by dependencies, so will always acheive as much parallelism as is available. In constrast, \Rattle has no such knowledge, so has to recover the parallelism by speculation, as per \ref{sec:speculation}. During the first execution, \Rattle has no knowledge about even which commands are coming next (as described in \S\ref{sec:monadic}), so has no choice but to execute each command serially, with less parallelism than \Make. In subsequent executions \Rattle will use speculation to always speculate on the second command (as it never has a hazard with the first), but never speculate on the third until the first two have finished (as they are known to conflict). Interestingly, sometimes \Rattle executes the third command (because it got to that point in the script), and sometimes it speculates it (because the previous two have finished) -- it is a race condition where both alternatives are equivalent. So \Rattle has less parallelism on the first execution, but using the cloud features, that can be reduced to the first execution \emph{ever}, rather than the first execution for a given user.

\paragraph{Overhead} The overhead inherent in \Rattle is greater than that of \Make as it hashes files, traces command execution, computes potential hazards to figure out speculation and writes to a shared cloud store. To measure the overhead we created a very simple pair of \texttt{main.c} and \texttt{util.c} files where \texttt{main.c} calls \texttt{printf} using a number computed by a function in \texttt{util.c}. We then measured the time to do an initial build, a rebuild when nothing had changed, a rebuild with whitespace changes to \texttt{main.c}, and a rebuild with changes to both C files. We did all the above with 1, 2 and 3 threads, on Linux. The numbers are:

\begin{tabular}{l|r|r|r}
Number of threads & 1 & 2 & 3 \\
\hline
Initial build \\
Nothing changed \\
\texttt{main.c} changed \\
Both C files changed \\
\end{tabular}

We see \Rattle has low overhead, in the millisecond range. We see three threads has no change over two threads, as this build contains no more parallelism opportunities.

\subsection{Measuring overhead}

In order to determine what overhead \Rattle and \Fsatrace introduce we took the latest version of \Fsatrace\footnote{Git commit 41fbba17da580f81ababb32ec7e6e5fd49f11473} and ran \texttt{make -j1}, capturing the commands that were executed, and reran those commands trying to isolate the overheads introduced by each part of \Rattle. The \Rattle command execution uses the command execution from \Shake \cite{shake} as a library, which in turn builds on the command execution from the Haskell \texttt{process} library. Therefore, we ran the commands in a clean build directory in 7 different ways:

\begin{enumerate}
\item Using \texttt{make -j1}
\item Using \texttt{System.Process} from the Haskell \texttt{process} library.
\item Using \texttt{cmd} from the Haskell \texttt{shake} library \cite{shake}, which builds on top of the \texttt{process} library.
\item Using \texttt{cmd} from \texttt{shake}, but wrapping the command with \Fsatrace.
\item Using \texttt{cmd} from \texttt{shake} with the \texttt{Traced} setting, which runs \Fsatrace and collects the result from a temporary directory.
\item Using \Rattle with no speculation or parallelism, and not storing any results to shared storage.
\item Using \Rattle with all features turned on, including shared storage.
\end{enumerate}

We ran all sets of commands five times, and took the average, on both Windows and Linux. On Windows \Fsatrace compiles in 25 commands (21 compiles, 4 links). On Linux \Fsatrace compiles in 9 commands (7 compiles, 2 links). On Linux the current build system produces write-write hazards, because it compiles some files (e.g. \texttt{shm.c}) twice, once with \texttt{-fPIC} (position independent code), and once without. However, both times it passes \texttt{-MMD} to cause \texttt{gcc} to produce \texttt{shm.d} which is used for dependencies -- we removed the \texttt{-MMD} flag as it doesn't impact the above benchmark.

% RAW RESULTS
%   WINDOWS
%     make: 10.154s, 10.711, 10.130, 10.161, 10.334 = 10.30
%     System.Process: 10.73s 10.77s 11.03s 11.47s 11.99s = 11.20s
%     shake.cmd: 12.13s 12.84s 13.23s 13.47s 14.15s = 13.16s
%     shake.cmd fsatrace: 16.66s 16.49s 16.74s 17.26s 17.54s = 16.94s
%     shake.cmd traced: 17.78s 17.39s 19.12s 18.50s 18.35s = 18.23s
%     rattle: 22.06s 22.12s 21.00s 21.15s 21.55s = 21.58s
%     rattle share: 21.93s 22.05s 21.43s 21.31s 21.34s = 21.61s
%   LINUX
%     Make: 1.89, 1.90, 1.87, 1.87, 1.85 = 1.88s
%     System.Process: 1.59s 1.85s 2.07s 1.78s 1.85s = 1.83s
%     shake.cmd: 2.03s 1.76s 1.78s 1.81s 1.77s = 1.83s
%     shake.cmd fsatrace: 1.85s 1.96s 1.94s 1.89s 1.91s = 1.91s
%     shake.cmd traced: 2.02s 2.22s 2.22s 2.22s 2.21s = 2.18s
%     rattle: 2.62s 2.32s 2.21s 2.14s 2.12s = 2.28s
%     rattle share: 2.36s 2.28s 2.27s 2.19s 2.27s = 2.27s

\vspace{3mm}
\begin{tabular}{l|rrr|rrr}
Commands & \multicolumn{3}{c|}{Windows} & \multicolumn{3}{c}{Linux} \\
\hline
Make & 10.3s & 100\% &  & 1.88s & 100\% & \\
prcoess & 11.2s & 109\% & +9\% & 1.83s & 97\% & -3\% \\
\Shake & 13.16s & 128\% & +19\% & 1.83s & 97\% & +0\% \\
\Shake + \Fsatrace & 16.94s & 164\% & +37\% & 1.91s & 102\% & +4\% \\
\Shake + \texttt{Traced} & 18.23s & 177\% & +13\% & 2.18s & 116\% & +14\% \\
\Rattle & 21.58s & 210\% & +33\% & 2.28s & 121\% & +5\% \\
\Rattle + everything & 21.61s & 210\% & +0\% & 2.27s & 121\% & -1\% \\
\end{tabular}
\vspace{3mm}

Both Windows and Linux have three columns -- the time taken (average of five runs), that time as a percentage of the \Make run, and the delta from the row above. Looking at Windows, we see that the total overhead of \Rattle makes the execution more than twice as slow. Of the parts, 37\% of the slowdown is from \Fsatrace, with the next greatest overhead being from \Rattle -- profiling shows that normalising filepaths is the major contributor. In contrast, on Linux, the total overhead is only 21\%, of which the majority comes from the \texttt{Traced} feature of \Shake, this time testing for the existence of files. These results show that tracing has minor but not insignificant on Linux, whereas on Windows can be a substantial performance reduction.

\subsection{Reimplementing Stack}

\Rattle assumes that each command is atomic - it cannot be subdivided into smaller parts. If a command is secretly two independent commands then they should usually be expressed as such so they can be individually skipped.

Compound commands: Sometimes a command will produce something that is user specific (not great for caching), but the next step will remove the user specificity (good for caching). To fix that we allow compound commands, by conjoining two commands with \texttt{\&\&}. Sometimes the sole purpose of the second command can be to strip machine-unique data from the first command.

As another example, the GHC package database has additional entries added every time a package is installed, making the output a consequence of the original file\footnote{As a consequence many build systems, including \Bazel and \Rattle, use multiple package databases with only one entry per database}.

and some memoisation operations (\texttt{memo})

\subsection{Rest of the evaluation}

Let's consider the VIM build system. It's wrong in lots of ways Sarah can describe. But these were expert software engineers - has anyone got it right? To a first approximation, no. Unless you go for something like Bazel, and then it's tedious but sandboxing makes you get it right.


\subsection{vim}

Vim is a popular text editor whose source code can be found on \href{https://github.com/vim/vim}{github}.  The majority of the source code is Vim script and C, and it is built with Make.  To build Make on a Unix based system one can merely call \Make from the top-level project directory.  To compare the original \Make based build to a new \Rattle build, we generated Vim over a series of commits checked-out from github with both the original build system and the adapted \Rattle build.  The \Rattle build script was created by recording every command executed by the original build, except for those invoking \Make.  Additionally, some commands which may have been separate shell commands in the original build were combined to create one command if they caused either \emph{read-write} or \emph{write-write} hazards.  A \Rattle build script was generated for each commit where the orginal build system changed or files were added to or removed from the project.  This was necessary since the \Rattle build was created from a literal list of hard-coded shell commands rather than the ideal Haskell program with variables.

% SS todo add list of the commits

Comparing building Vim \cite{} with \Make and with \Rattle for commits \emph{21109272f} to \emph{7cc96923c}.  For two commits \Make and \Rattle did noticeably different work; note, both of these commits were build incrementally, \emph{21109272f} was built from scratch by both build systems and all subsequent commits were built incrementally.

\begin{description}
\item[\emph{e258368b4}]
  Looking at the git commit, only two files changed: \emph{osdef.sh} and \emph{version.c}.  Rattle re-ran \emph{osdef.sh}, which generates \emph{osdef.h}.  Rattle also rebuilt \emph{version.o}, which depends on \emph{version.c}
  The header file \emph{osdef.h} did not change when it was re-created, which \Rattle detected since it uses hashes to determine when files have changed.  \Make, which uses timestamps, did not detect this and built an additional 109 object files because they depend on \emph{osdef.h}

  Rattle avoided rebuilding 109 object files by using a more accurate standard for detecting changes in dependencies.

\item[\emph{a259d8d30}]
  The files changed by the commit are: \emph{src/evalfunc.c}, \emph{src/proto/evalfunc.pro},
  \emph{src/testdir/test\_vim9\_script.vim}, \emph{src/userfunc.c}, \emph{src/version.c}, and
  \emph{src/vim9compile.c}.
  \Rattle rebuilt the following object files, because \emph{evalfunc.pro} changed.
  \begin{description}
  \item[Object files rebuilt which did \emph{not change}.] \Rattle rebuilt 32 object files because \emph{evalfunc.pro} changed, but the object files did not change when rebuilt.
    %arabic.o, blob.o, blowfish.o, crypto.o, dict.o, evalbuffer.o, evalwindow.o, ex\_cmds2.o, ex\_eval.o, hashtab.o, list.o, map.o, move.o, pathdef.o, popupmenu.o, session.o, sign.o, sound.o,
    %undo.o, vim9execute.o, vim9script.o, bufwrite.o, gui\_beval.o, xdiffi.o, xemit.o, xprepare.o, xutils.o, xhistogram.o, xpatience.o, charset.o, json.o, memfile.o.
  \item[Object files rebuilt which did \emph{change}.] \Rattle rebuilt an additional 78 object files because \emph{evalfunc.pro} changed, whose object files did change after being rebuilt.
    4 of these object files corresponding c files had changed, also causing them to rebuild.

  % arglist.o, autocmd.o, beval.o, buffer.o, change.o, cindent.o, cmdexpand.o, cmdhist.o, crypt_zip.o, debugger.o, diff.o, digraph.o, drawline.o, drawscreen.o, edit.o, eval.o
  % evalfunc.o (evalfunc.c had also changed), evalvars.o, ex\_cmds.o, ex\_docmd.o, ex\_getln.o, fileio.o, filepath.o, findfile.o, fold.o, getchar.o, hardcopy.o, highlight.o, if\_cscope.o
  % if\_xcmdsrv.o, indent.o, insexpand.o, mark.o, mbyte.o, memline.o, menu.o, misc1.o, misc2.o, mouse.o, normal.o, ops.o, option.o, optionstr.o, os\_unix.o, popupwin.o
  % profiler.o, pty.o, quickfix.o, regexp.o, register.o, screen.o, scriptfile.o, search.o, sha256.o, spell.o, spellfile.o, spellsuggest.o, syntax.o, tag.o, term.o, terminal.o
  % testing.o, textprop.o, ui.o, usercmd.o, userfunc.o (userfunc.c also changed), vim9compile.o (vim9compile.c alos changed) , viminfo.o, window.o, gui.o, gui\_gtk.o,
    % gui\_gtk\_x11.o, gui\_gtk\_f.o, netbeans.o, channel.o, main.o, message.o version.o (version.c also changed)
  \end{description}
\end{description}

\Make rebuilt 4 object files, the ones whose corresponding c files had changed.  It didn't rebuild the other object files rebuilt by \Rattle because the Makefile does not state that these object files
depend on \emph{src/proto/evalfunc.pro}.

% SS todo add timing data

\subsection{node}

% Brief into to the project
Node.js is a JavaScript runtime built on Chrome's V8 Javascript engine and can be found on \href{``https://github.com/nodejs/node''}{github}.  The project is largely written in JavaScript, C++, Python, and C, and is built using Make and a meta-build tool called \emph{Generate Your Projects (GYP)}.  To build Node.js from source, a user first runs \emph{./configure} which runs a python script that configures the build and runs GYP.  GYP generates the majority of the Makefiles used to build the project.

GYP takes a series of \emph{.gyp} files and produces the project build from those.  It puts all generated files in the project's \emph{out} directory and generates a separate \emph{*.mk} Makefile for each target, all of which are included by the top-level Makefile.  The generated top-level Makefile includes a \emph{do\_cmd} function which first checks if a command changed since the last time it was run, and if it has runs the command.  Additionally, it writes the command run to a generated dependency file, and if the command run was a \emph{g++} command that produced a file with dependencies, the dependencies in that file are cleaned up and written to the generated dependency file.

These dependency files are included in the top-level \emph{out/Makefile}, presumably so on future runs Make can consider the recorded dependencies of these object files as well as check whether the command has changed since it was previously run.  Most of these targets include the dependency \emph{FORCE\_DO\_CMD} which is an empty phony target and serves the purpose of forcing the build to check everytime whether the command has changed since it was previously run. Each time a command is re-run, these dependency files are re-generated.

% Explain the makefile insanity and all of this dependency stuff they do
% Still trying to make coherent since of what this gyp is doing, so here is my current understanding

The build both seems to be using a form of tracing to keep track of accurate dependencies as well as tracking whether or not the build itself has changed.  \Rattle would make it unnecessary for the build to explicitely do this, since it internally traces and tracks the depencencies of all commands run, and doesn't need to worry about when a build changes.

% The generator/make.py

% what is this
% # Helper that is non-empty when a prerequisite changes.
% # Normally make does this implicitly, but we force rules to always run
% # so we can check their command lines.
% #   $? -- new prerequisites
% #   $| -- order-only dependencies
% prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))

% # do_cmd: run a command via the above cmd_foo names, if necessary.
% # Should always run for a given target to handle command-line changes.

% Explain the intermediate files and how on a rebuild with no changes stuff still happens

When building certain targets, \emph{.intermediate} files are created and at the end of the build deleted.  These \emph{.intermediate} commands appear to be for doing code generation.  So, the generated files depend on the \emph{.intermediate} target which runs the code generator.  As with the object file targets mentioned, a \emph{.intermediate.d} dependency file is generated for the \emph{.intermediate} target.  This dependency file contains the \emph{.intermediate} code generation command run, so the build can check whether the command changed since it was last run.

These \emph{.intermediate} files are specified as prereqs of the special \Make target {.INTERMEDIATE}, which means that when one does not exist \Make won't bother updating it unless one of its prerequisites has changed.  Because these \emph{.intermediate} targets have \emph{DO\_/FORCE\_CMD} as a prereq they always run.  This would enable the build to check if the command changed since it was last run, but this only works if the Makefile includes the dependency file storing that information.  The dependency files of these \emph{.intermediate} targets, which run everytime, are not included in the Makefile.  Because of this the Makefile thinks the command has never run before, causing them to run everytime.  Even if the Makefile is modified to include the dependency files of these \emph{.intermediate} targets, the targets still execute the recipe which does the file generation even though the command has not changed. % SS comment on this further when I fully understand why the commands are registering as changed...

  % Other things like parallelism and rattle rebuilding less

It appears the authors of this build are attempting to keep track of accurate dependencies by recording them every time a command runs, they are also tracking the build by recording every command run and checking whether a command or its prerequisites have changed when deciding whether to run it.  The scheme to accomplish this is in my opinion quite complicated and confusing and relies on various hacks to work around \Make and the fact that this isn't a full-fledged programming language.  \Rattle accomplishes both of these things the build authors are trying to accomplish with \Make without forcing them to work so hard.

To compare the \Make based build to a \Rattle version, we built Node.js over a series of commits checked-out from github with both the original build system and the adapted \Rattle build.  The \Rattle build was created by recording every command executed by the original build, except for the commands creating dependency files and those invoking \Make.  A new such \Rattle build script was generated for any commit where the original build system changed or files were added to or removed from the project.
% data


% SS add the differences in commits
% 1. make list of commits run

% in order from latest to oldest.
% d80c40047b 0fe810168b 22724894c9 ab9e89439e cb210110e9 d10927b687
% 023ecbccc8 be6596352b [54c1a09202] 470511ae78 25c3f7c61a 13fe56bbbb
% [43fb6ffef7] a171314003 dd4c62eabe abe6a2e3d1 9225939528 d4c81be4a0
% 38aa31554c 1d9511127c d227d22bd9 5cf789e554 d65e6a5017 24e81d7c5a
% 2cd9892425 [64161f2a86] 0f8941962d 2170259940 32f63fcf0e 2462a2c5d7
% b851d7b986 70c32a6d19 3d456b1868 f2ec64fbcf 59a1981a22 [7b7e7bd185]
% 78743f8e39 a5d4a397d6
% [] indicate a commit where build appears to have changed. so need new rattle build too


% So, pretty much everything needs to be re-run. awesome.

% 5. Record here
% 6. Run on tank? with various threads; ask sam





% Comment from the Makefile
%# .buildstamp needs $(NODE_EXE) but cannot depend on it
%# directly because it calls make recursively.  The parent make cannot know
%# if the subprocess touched anything so it pessimistically assumes that
%# .buildstamp is out of date and need a rebuild.
%# Just goes to show that recursive make really is harmful...
%# TODO(bnoordhuis) Force rebuild after gyp update.
