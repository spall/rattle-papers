\section{Evaluation}
\label{sec:evaluation}

In this section we evaluate the design from \S\ref{sec:design}, specifically our implemenation as per \S\ref{sec:implementation}.

\subsection{Validating the claims from \S\ref{sec:introduction}}

In \S\ref{sec:introduction} we claimed that the following build script is ``just as good'' as a proper \Make script.

\begin{verbatim}
gcc -c main.c
gcc -c util.c
gcc -o main.exe main.o util.o
\end{verbatim}

There are two axes on which to measure ``just as good'' -- correctness and performance. Performance can be further broken down into how much rebuilds, how much parallelism can be acheived, and overhead.

\paragraph{Correctness} \Rattle is correct, in that the reference semantics is running all the commands, and as we have shown in \S\ref{sec:design} and \S\ref{sec:proof}, \Rattle obeys that semantics. In contrast, the \Make version may have missing dependencies which causes it not to rebuild. Examples of failure to rebuild include both if \texttt{gcc} changes, one of the system headers used by \texttt{gcc} or any headers included but not listed in the \Make script.

\paragraph{Rebuilding too much} \Rattle only rebuilds a command if some of the inputs to a command have changed. It is possible that a command only depends on a subset of those inputs, but at the level of abstraction \Rattle works, it never rebuilds too much. As a matter of implementation, to implement cloud builders as per \ref{sec:cloud_builds}, \Rattle uses hashes of the file contents. In contrast, \Make uses the modification time, so if a file is modified, but it's contents do not change, \Make will rebuild but \Rattle will not (e.g. using \texttt{touch}). It would be possible for \Make to use modification times, if it chose to store additional metadata not in the file system.

\paragraph{Parallelism} The script from \S\ref{sec:introduction} has three commands, the first two of which can run in parallel, the the third of which must wait for the first two to finish. \Make is given all this information by dependencies, so will always acheive as much parallelism as is available. In constrast, \Rattle has no such knowledge, so has to recover the parallelism by speculation, as per \ref{sec:speculation}. During the first execution, \Rattle has no knowledge about even which commands are coming next (as described in \S\ref{sec:monadic}), so has no choice but to execute each command serially, with less parallelism than \Make. In subsequent executions \Rattle will use speculation to always speculate on the second command (as it never has a hazard with the first), but never speculate on the third until the first two have finished (as they are known to conflict). Interestingly, sometimes \Rattle executes the third command (because it got to that point in the script), and sometimes it speculates it (because the previous two have finished) -- it is a race condition where both alternatives are equivalent. So \Rattle has less parallelism on the first execution, but using the cloud features, that can be reduced to the first execution \emph{ever}, rather than the first execution for a given user.

\paragraph{Overhead} The overhead inherent in \Rattle is greater than that of \Make as it hashes files, traces command execution, computes potential hazards to figure out speculation and writes to a shared cloud store. To measure the overhead, and prove the other claims in this section, we created a very simple pair of \texttt{main.c} and \texttt{util.c} files where \texttt{main.c} calls \texttt{printf} using a string computed by a function in \texttt{util.c}. We then measured the time to do 1) an initial build; 2) a rebuild when nothing had changed; 3) a rebuild with whitespace changes to \texttt{main.c}; 4) a rebuild with meaningfully changes to \texttt{main.c}; 5) a rebuild with meaingfully changes to both C files. We did all the above with 1, 2 and 3 threads, on Linux. To check speculation was happening, we modified \texttt{gcc} to sleep for 1 second before starting. The numbers are:

% RAW RESULTS
% $ rattle-benchmark intro
%   make   -j1: 3.35s 0.00s 2.19s 2.19s 3.28s
%   rattle -j1: 3.28s 0.00s 1.12s 2.16s 3.29s
%   make   -j2: 2.18s 0.00s 2.19s 2.23s 2.22s
%   rattle -j2: 3.28s 0.00s 1.12s 2.21s 2.20s
%   make   -j3: 2.20s 0.00s 2.19s 2.19s 2.19s
%   rattle -j3: 3.36s 0.00s 1.10s 2.22s 2.20s
%   make   -j4: 2.20s 0.00s 2.19s 2.18s 2.19s
%   rattle -j4: 3.28s 0.00s 1.14s 2.21s 2.20s

\vspace{3mm}
\begin{tabular}{l|r|r||r|r||r|r}
Number of threads & \multicolumn{2}{c||}1 & \multicolumn{2}{c||}2 & \multicolumn{2}{c}3 \\
Tool & \Make & \Rattle & \Make & \Rattle & \Make & \Rattle \\
\hline
Initial build & 3.35s & 3.28s & 2.18s & 3.28s & 2.20s & 3.36s \\
Nothing changed & 0.00s & 0.00s & 0.00s & 0.00s & 0.00s & 0.00s \\
\texttt{main.c} changed whitespace & 2.19s & 1.12s & 2.19s & 1.12s & 2.19s & 1.10s \\
\texttt{main.c} changed meaingfully & 2.19s & 2.16s & 2.23s & 2.21s & 2.19s & 2.22s \\
Both C files changed meaningfully & 3.28s & 3.29s & 2.22s & 2.20s & 2.19s & 2.20s \\
\end{tabular}
\vspace{3mm}

As expected, we see that in the initial build \Rattle doesn't exhibit parallelism, but \Make can. In constrast, \Rattle can benefit when a file changes in whitespace only and the resulting object file doesn't change, while \Make can't. We see 3 threads has no change over 2 threads, as this build contains no more parallelism opportunities. Comparing the non-sleep portion of the build, \Make and \Rattle are quite evenly matched, typically within a few milliseconds, showing low overheads -- we focus on the overheads in the next section.

\subsection{Measuring overhead}
\label{sec:overhead}

In order to determine what overhead \Rattle and \Fsatrace introduce we took the latest version of \Fsatrace\footnote{Git commit 41fbba17da580f81ababb32ec7e6e5fd49f11473} and ran \texttt{make -j1}, capturing the commands that were executed, and reran those commands trying to isolate the overheads introduced by each part of \Rattle. The \Rattle command execution uses the command execution from \Shake \cite{shake} as a library, which in turn builds on the command execution from the Haskell \texttt{process} library. Therefore, we ran the commands in a clean build directory in 7 different ways:

\begin{enumerate}
\item Using \texttt{make -j1}
\item Using \texttt{System.Process} from the Haskell \texttt{process} library.
\item Using \texttt{cmd} from the Haskell \texttt{shake} library \cite{shake}, which builds on top of the \texttt{process} library.
\item Using \texttt{cmd} from \texttt{shake}, but wrapping the command with \Fsatrace.
\item Using \texttt{cmd} from \texttt{shake} with the \texttt{Traced} setting, which runs \Fsatrace and collects the result from a temporary directory.
\item Using \Rattle with no speculation or parallelism, and not storing any results to shared storage.
\item Using \Rattle with all features turned on, including shared storage.
\end{enumerate}

We ran all sets of commands five times, and took the average of the three fastest, on both Windows and Linux. On Windows \Fsatrace compiles in 25 commands (21 compiles, 4 links). On Linux \Fsatrace compiles in 9 commands (7 compiles, 2 links). On Linux the current build system produces write-write hazards, because it compiles some files (e.g. \texttt{shm.c}) twice, once with \texttt{-fPIC} (position independent code), and once without. However, both times it passes \texttt{-MMD} to cause \texttt{gcc} to produce \texttt{shm.d} which is used for dependencies -- we removed the \texttt{-MMD} flag as it doesn't impact the above benchmark.

% RAW RESULTS (final number is avg of fastest 3, to ignore swapping etc)
% $ rattle-benchmark micro
%   WINDOWS (with Windows Defender)
%     make: 13.14s 10.47s 11.04s 11.67s 11.86s = 11.06s
%     System.Process: 12.28s 12.41s 12.90s 13.07s 13.24s = 12.53s
%     shake.cmd: 13.59s 13.83s 13.88s 13.99s 14.08s = 13.77s
%     shake.cmd fsatrace: 16.54s 17.06s 16.55s 16.41s 16.39s = 16.45s
%     shake.cmd traced: 16.52s 16.42s 16.84s 16.69s 16.70s = 16.54s
%     rattle: 20.70s 18.51s 18.93s 18.50s 18.51s = 18.51s
%     rattle share: 18.94s 19.10s 18.74s 18.74s 18.63s = 18.70s
%   WINDOWS (no Windows Defeneder)
%     make: 12.31s 9.73s 9.98s 14.97s 10.16s = 9.96s
%     System.Process: 10.20s 10.25s 10.32s 10.40s 10.44s = 10.26s
%     shake.cmd: 10.53s 10.68s 10.62s 10.59s 10.70s = 10.58s
%     shake.cmd fsatrace: 12.68s 12.58s 12.85s 12.72s 12.80s = 12.66s
%     shake.cmd traced: 13.31s 12.99s 12.86s 13.90s 16.26s = 13.06s
%     rattle: 16.59s 14.51s 14.48s 14.82s 14.30s = 14.43s
%     rattle share: 14.56s 14.48s 14.62s 14.62s 14.56s = 14.53s
%   LINUX
%     make: 1.26s 1.22s 1.19s 1.23s 1.17s = 1.19s
%     System.Process: 1.19s 1.19s 1.22s 1.24s 1.16s = 1.18s
%     shake.cmd: 1.20s 1.18s 1.17s 1.21s 1.18s = 1.17s
%     shake.cmd fsatrace: 1.26s 1.20s 1.26s 1.25s 1.25s = 1.23s
%     shake.cmd traced: 1.25s 1.23s 1.27s 1.21s 1.23s = 1.23s
%     rattle: 1.50s 1.29s 1.25s 1.25s 1.25s = 1.25s
%     rattle share: 1.31s 1.31s 1.31s 1.26s 1.24s = 1.27s

\vspace{3mm}
\begin{tabular}{l|rrr|rrr}
Commands & \multicolumn{3}{c|}{Windows} & \multicolumn{3}{c}{Linux} \\
\hline
Make & 9.96s & 100\% &  & 1.19s & 100\% & \\
process & 10.26s & 103\% & +3\% & 1.18s & 99\% & -1\% \\
\Shake & 10.58s & 106\% & +3\% & 1.17s & 98\% & -1\% \\
\Shake + \Fsatrace & 12.66s & 127\% & +21\% & 1.23s & 103\% & +5\% \\
\Shake + \texttt{Traced} & 13.06s & 131\% & +4\% & 1.23s & 103\% & +0\% \\
\Rattle & 14.43s & 145\% & +14\% & 1.25s & 105\% & +2\% \\
\Rattle + everything & 14.53s & 146\% & +1\% & 1.27s & 107\% & +2\% \\
\end{tabular}
\vspace{3mm}

Both Windows and Linux have three columns -- the time taken (average of five runs), that time as a percentage of the \Make run, and the delta from the row above. The results are significantly different between platforms:

\paragraph{Windows} On Windows, we see that the total overhead of \Rattle makes the execution 46\% slower. Of the parts, 21\% of the slowdown is from \Fsatrace, with the next greatest overhead being from \Rattle. Of the \Rattle overhead, one of the things that is necessarily slower on Windows is canonicalising filepaths. Using the default NTFS file system, Windows considers paths to be case insensitive. As a result, we observe paths like \verb"C:\windows\system32\KERNELBASE.dll", which in actual fact are on disk called \verb"C:\Windows\System32\KernelBase.dll", but can also be accessed by names such as \verb"C:\Windows\System32\KERNEL~1.DLL". Unfortunately, Windows also supports case sensitive disks, so it's also not sufficient to just lowercase them. Furthermore, disabling the anti-virus (Windows Defeneder) has a significant impact on the result -- these results are with the anti-virus disabled.

\paragraph{Linux} In contrast, on Linux, the total overhead is only 7\%, of which nearly all (5\%) comes from the tracing.

\postparagrahs

These results show that tracing has minor but not insignificant on Linux, whereas on Windows can be a substantial performance reduction. As a consequence, we focus on the results under Linux.

\subsection{Redis}
% SS is subsection redis being here a typo?

\begin{tikzpicture}
\begin{axis}[
  title=Compile time in seconds,
  width=\textwidth,
  height=7cm,
  xlabel={Time at each successive commit},
  ylabel={Seconds},
  ymin=0,
  xmin=0,
]
\addplot table [x expr=\coordindex, y=make1] {data/redis.dat}; 	\addlegendentry{\Make -j1}
\addplot table [x expr=\coordindex, y=make4] {data/redis.dat}; 	\addlegendentry{\Make -j4}
\addplot table [x expr=\coordindex, y=rattle1] {data/redis.dat}; 	\addlegendentry{\Rattle -j1}
\addplot table [x expr=\coordindex, y=rattle4] {data/redis.dat}; 	\addlegendentry{\Rattle -j4}
\addplot table [x expr=\coordindex, y=rattle4_noshared] {data/redis.dat}; 	\addlegendentry{\Rattle -j4 (no shared)}
\end{axis}
\end{tikzpicture}

\begin{comment}
% I reimplemented Stack in Rattle. Not sure it's useful given how much other evaluation stuff we have.
\subsection{Reimplementing Stack}

\Rattle assumes that each command is atomic - it cannot be subdivided into smaller parts. If a command is secretly two independent commands then they should usually be expressed as such so they can be individually skipped.

Compound commands: Sometimes a command will produce something that is user specific (not great for caching), but the next step will remove the user specificity (good for caching). To fix that we allow compound commands, by conjoining two commands with \texttt{\&\&}. Sometimes the sole purpose of the second command can be to strip machine-unique data from the first command.

As another example, the GHC package database has additional entries added every time a package is installed, making the output a consequence of the original file\footnote{As a consequence many build systems, including \Bazel and \Rattle, use multiple package databases with only one entry per database}.

and some memoisation operations (\texttt{memo})
\end{comment}

\subsection{Rest of the evaluation}

Let's consider the VIM build system. It's wrong in lots of ways Sarah can describe. But these were expert software engineers - has anyone got it right? To a first approximation, no. Unless you go for something like Bazel, and then it's tedious but sandboxing makes you get it right.


\subsection{vim}

Vim is a popular text editor whose source code can be found on \href{https://github.com/vim/vim}{github}.  The majority of the source code is Vim script and C, and it is built with Make.  To build Make on a Unix based system one can merely call \Make from the top-level project directory.  To compare the original \Make based build to a new \Rattle build, we generated Vim over a series of commits checked-out from github with both the original build system and the adapted \Rattle build.  The \Rattle build script was created by recording every command executed by the original build, except for those invoking \Make.  Additionally, some commands which may have been separate shell commands in the original build were combined to create one command if they caused either \emph{read-write} or \emph{write-write} hazards.  A \Rattle build script was generated for each commit where the orginal build system changed or files were added to or removed from the project.  This was necessary since the \Rattle build was created from a literal list of hard-coded shell commands rather than the ideal Haskell program with variables.

% SS todo add list of the commits

Comparing building Vim \cite{} with \Make and with \Rattle for commits \emph{21109272f} to \emph{7cc96923c}.  For two commits \Make and \Rattle did noticeably different work; note, both of these commits were build incrementally, \emph{21109272f} was built from scratch by both build systems and all subsequent commits were built incrementally.

% todo compare sequential 
% SS todo add timing data

\subsection{node}

% Brief into to the project
Node.js is a JavaScript runtime built on Chrome's V8 Javascript engine and can be found on \href{``https://github.com/nodejs/node''}{github}.  The project is largely written in JavaScript, C++, Python, and C, and is built using Make and a meta-build tool called \emph{Generate Your Projects (GYP)}.  To build Node.js from source, a user first runs \emph{./configure} which runs a python script that configures the build and runs GYP.  GYP generates the majority of the Makefiles used to build the project.

GYP takes a series of \emph{.gyp} files and produces the project build from those.  It puts all generated files in the project's \emph{out} directory and generates a separate \emph{*.mk} Makefile for each target, all of which are included by the top-level Makefile.  The generated top-level Makefile includes a \emph{do\_cmd} function which first checks if a command changed since the last time it was run, and if it has runs the command.  Additionally, it writes the command run to a generated dependency file, and if the command run was a \emph{g++} command that produced a file with dependencies, the dependencies in that file are cleaned up and written to the generated dependency file.

These dependency files are included in the top-level \emph{out/Makefile}, presumably so on future runs Make can consider the recorded dependencies of these object files as well as check whether the command has changed since it was previously run.  Most of these targets include the dependency \emph{FORCE\_DO\_CMD} which is an empty phony target and serves the purpose of forcing the build to check everytime whether the command has changed since it was previously run. Each time a command is re-run, these dependency files are re-generated.

% Explain the makefile insanity and all of this dependency stuff they do
% Still trying to make coherent since of what this gyp is doing, so here is my current understanding

The build both seems to be using a form of tracing to keep track of accurate dependencies as well as tracking whether or not the build itself has changed.  \Rattle would make it unnecessary for the build to explicitely do this, since it internally traces and tracks the depencencies of all commands run, and doesn't need to worry about when a build changes.

% The generator/make.py

% what is this
% # Helper that is non-empty when a prerequisite changes.
% # Normally make does this implicitly, but we force rules to always run
% # so we can check their command lines.
% #   $? -- new prerequisites
% #   $| -- order-only dependencies
% prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))

% # do_cmd: run a command via the above cmd_foo names, if necessary.
% # Should always run for a given target to handle command-line changes.

% Explain the intermediate files and how on a rebuild with no changes stuff still happens

When building certain targets, \emph{.intermediate} files are created and at the end of the build deleted.  These \emph{.intermediate} commands appear to be for doing code generation.  So, the generated files depend on the \emph{.intermediate} target which runs the code generator.  As with the object file targets mentioned, a \emph{.intermediate.d} dependency file is generated for the \emph{.intermediate} target.  This dependency file contains the \emph{.intermediate} code generation command run, so the build can check whether the command changed since it was last run.

These \emph{.intermediate} files are specified as prereqs of the special \Make target {.INTERMEDIATE}, which means that when one does not exist \Make won't bother updating it unless one of its prerequisites has changed.  Because these \emph{.intermediate} targets have \emph{DO\_/FORCE\_CMD} as a prereq they always run.  This would enable the build to check if the command changed since it was last run, but this only works if the Makefile includes the dependency file storing that information.  The dependency files of these \emph{.intermediate} targets, which run everytime, are not included in the Makefile.  Because of this the Makefile thinks the command has never run before, causing them to run everytime.  Even if the Makefile is modified to include the dependency files of these \emph{.intermediate} targets, the targets still execute the recipe which does the file generation even though the command has not changed. % SS comment on this further when I fully understand why the commands are registering as changed...

  % Other things like parallelism and rattle rebuilding less

It appears the authors of this build are attempting to keep track of accurate dependencies by recording them every time a command runs, they are also tracking the build by recording every command run and checking whether a command or its prerequisites have changed when deciding whether to run it.  The scheme to accomplish this is in my opinion quite complicated and confusing and relies on various hacks to work around \Make and the fact that this isn't a full-fledged programming language.  \Rattle accomplishes both of these things the build authors are trying to accomplish with \Make without forcing them to work so hard.

To compare the \Make based build to a \Rattle version, we built Node.js over a series of commits checked-out from github with both the original build system and the adapted \Rattle build.  The \Rattle build was created by recording every command executed by the original build, except for the commands creating dependency files and those invoking \Make.  A new such \Rattle build script was generated for any commit where the original build system changed or files were added to or removed from the project.
% data


% SS add the differences in commits
% 1. make list of commits run

% in order from latest to oldest.
% d80c40047b 0fe810168b 22724894c9 ab9e89439e cb210110e9 d10927b687
% 023ecbccc8 be6596352b [54c1a09202] 470511ae78 25c3f7c61a 13fe56bbbb
% [43fb6ffef7] a171314003 dd4c62eabe abe6a2e3d1 9225939528 d4c81be4a0
% 38aa31554c 1d9511127c d227d22bd9 5cf789e554 d65e6a5017 24e81d7c5a
% 2cd9892425 [64161f2a86] 0f8941962d 2170259940 32f63fcf0e 2462a2c5d7
% b851d7b986 70c32a6d19 3d456b1868 f2ec64fbcf 59a1981a22 [7b7e7bd185]
% 78743f8e39 a5d4a397d6
% [] indicate a commit where build appears to have changed. so need new rattle build too


% So, pretty much everything needs to be re-run. awesome.

% 5. Record here
% 6. Run on tank? with various threads; ask sam


% Comment from the Makefile
%# .buildstamp needs $(NODE_EXE) but cannot depend on it
%# directly because it calls make recursively.  The parent make cannot know
%# if the subprocess touched anything so it pessimistically assumes that
%# .buildstamp is out of date and need a rebuild.
%# Just goes to show that recursive make really is harmful...
%# TODO(bnoordhuis) Force rebuild after gyp update.


\subsection{tmux}

Tmux is a terminal multiplexer whose sourcecode is available on  \href{``https://github.com/vim/vim''}{github}.  It can be built from source using \emph{autoconf}, \emph{automake}, \emph{pkg-config}, and \emph{make}.  To build Tmux from source grabbed from github one does the following:

\begin{verbatim}
sh autogen.sh
./configure
make
\end{verbatim}

To compare a \Rattle based Tmux build to the \Make based one, we first ran \emph{sh autogen.sh} and \emph{./configure}, and then used the resulting Makefile(s) to generate the Rattle build scripts.  A new Rattle build script was generated for any commit where the build appeared to have changed or a file was added or deleted from the repository.

Tmux was built over a series of 40 commits with both \Make and \Rattle.  The commands run by each build system for each command were then compared.  For single threaded \Rattle and \Make, for 33 out of 40 commits, \Rattle and \Make ran the same commands, for 4 commits, \Make ran 1 more non-trivial command than \Rattle, but for 3 commits \Rattle ran substantially more cmds than \Make did.

These 3 commits were ones where new \Rattle build scripts were generated because something about the build or project had changed.  For two of these commits the version number of Tmux had changed which caused the textual contents of majority of the commands to change.  \Rattle viewed these as new commans and therefore ran them.  For the 3rd commit, \Rattle ran 125 commands more than \Make did because a command flag changed, which caused the textual contents of the majority of the commands to change, so \Rattle viewed them as new commands.

% todo add details about parallel version and hazards
% todo timing data



% 47174f51
% 150 cmds in file - 10 for make
% 140 cmds run by rattle not run by make
% how many did rattle run period?
% there were 141 cmds in the script.
% so what command did make run too?

%4822130b was a new build script

% 685eb381 also a new build script

% I wonder if I don't do sh autogen and configure if that wouldn't happen?



% For 1 thread

% commits where did same things: close enough; ignoring commands like rm tmux

% obf153da 0c6c8c4e 0eb7b547 19d5f4a0 22e9cf04 24cd726d 32be954b 37919a6b 3e701309
% 400750bb 43b36752 4694afb  470cba35 54553903 60ab7144 61b075a2 6c28d0dd 6f0241e6
% 74b42407 7cdf5ee9 7f3feb18 8457f54e 8b22da69 9900ccd0 a01c9ffc a4d8437b ba542e42
% bc36700d c391d50c c915cfc7 cdf13837 e9b12943 fdbc1116


% commits with differences
% 47174f51 (commit where make did automake stuff and rattle re-ran everything because a version number changed)
% 4822130b
% 685eb381

% 7eada28f: make did ./etc/ylwrap ....
% ed16f51e: make did ./etc/ylwrap ...
% ee3d3db3: make built tmux.o
% f3ea318a: make did ./etc/ylwrap ...


% commits
% ed16f51e 61b075a2 e9b12943 3e701309 8457f54e a01c9ffc cdf13837 74b42407 0eb7b547 f3ea318a 7cdf5ee9 ee3d3db3 685eb381 60ab7144 7eada28f 7f3feb18 8b22da69 bc36700d 32be954b 6f0241e6 19d5f4a0 43b36752 0bf153da 4822130b 47174f51 c915cfc7 54553903 400750bb 470cba35 a4d8437b 6c28d0dd 24cd726d 9900ccd0 c391d50c 0c6c8c4e fdbc1116 37919a6b 22e9cf04 ba542e42 4694afb

\subsection{redis}

\subsection{openssl}
