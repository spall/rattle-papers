\newcommand{\claim}{\noindent Claim: }
\renewcommand{\proof}{\vspace{1mm}\noindent Proof: }
\newcommand{\refutation}{\vspace{1mm}\noindent Refutation: }

\section{Correctness}
\label{sec:proof}

The design of \Rattle relies on taking a sequence of commands and instead of running them all sequentially, rather running them in different orders and with speculation. In this section we prove that the manipulations we perform are safe with respect to the reference semantics. Throughout these proofs we assume the commands themselves are pure functions from the inputs to their outputs (as reported by tracing).

\subsection{Hazards, formally}
\label{sec:hazards_formally}

In section \S\ref{sec:proof:classify_hazard} we introduce the notion of hazards through intuition and how they are used. Here we give more precise definitions:

\begin{description}
\item[Read-write hazard] A build has a \emph{read-write hazard} if one file is read after it is written. Given the limitations of tracing (see \S\ref{sec:tracing}) we require the stronger property that for all files which are both read and written in a single build, the command which did the write must have completed before any commands reading it start.
\item[Write-write hazard] A build has a \emph{write-write hazard} if one file is written to after it is written. Stated equivalently, a build has a write-write hazard if more than one command in a build writes to it.
\end{description}

\subsection{Argument for correctness}
\label{sec:argument}

We define the following terms:

\begin{description}
\item[Command] A command $c$ reads a set of files ($c_r$), and writes a set of files ($c_w$). We assume the set of files are disjoint ($c_r \cap c_r \equiv \emptyset$), as per \S\ref{sec:skipping_unnecessary}.
\item[Deterministic command] A command is deterministic if for any set of files it reads, it always writes the same set of files. We assume commands are deterministic for this proof.
\item[Fixed point] A deterministic command will have no effect if none of the files it reads or writes have changed since the last time it has run. Since it is deterministic, and its reads/writes are disjoint, the same reads will take place, the same computation will follow, and then the original values will be rewritten as they were before. We describe such a command as having \emph{reached a fixed point}.
\item[Correct builds] If a build containing a set of commands $C$ has reached a fixed point for every command $c$ within the set, then it is a correct build system as per the definition in \S\ref{sec:hazards}.
\end{description}

\claim If a set of commands $D$ is run, and no hazards arise, then every command within $D$ has reached a fixed point.

\proof A command $c$ has reached a fixed point if none of the files have changed. Taking $c_r$ and $c_w$ separately:

\begin{enumerate}
\item None of the files $c_w$ have changed. Within a set of commands $D$, if any file was written to by more than one command it would result in a write-write hazard. Therefore, if a command wrote to a file, it must have been the \emph{only} command to write to that file.
\item None of the files $c_r$ have changed. For a read file to have changed would require it to be written to afterwards. If a file is read from then written to it is a read-write hazard, so the files $c_r$ can't have changed.
\end{enumerate}

As a consequence, all commands within $D$ must have reached a fixed point.

\subsection{No rebuilds}
\label{sec:proof:no_rebuild}

\claim A build with deterministic control logic that completes with no hazards has reached a fixed point.

\proof The deterministic control logic means that the set of commands will not change unless the results of the commands do. The proof in \S\ref{sec:argument} means that the commands will not change the values of any files, therefore the set of commands won't change and the build is at a fixed point.

\subsection{Reordered builds}
\label{sec:proof:reorder}

\claim Given a script with no hazards when executed sequentially, with the same initial file contents, any interleaving of those commands that also has no hazards will result in an equivalent output.

\proof The proof from \S\ref{sec:argument} shows that any script with no hazards will result in a fixed point. To prove equivalency we defined the inputs as the set of files that commands read from, but no command writes to, namely:

For any file states where the inputs are equivalent, there is only one fixed point. The commands only read and write from files that are in the inputs, or files that are written by another command. The first command that writes its output can only have been influenced inputs, since if it read any other writes, there would be a read-write hazard, so that first output must be a consequence of only inputs. The second command can only look at the inputs and the files written by the first command, all of which are determined by the inputs. By induction we can see that all outputs must be influenced only by the inputs.

To complete the proof we require the inputs before are equivalent, which is part of the claim.

\subsection{Parallel commands}
\label{sec:proof:parallel}

\claim Given a script with no hazards when executed sequentially, any parallel or interleaved execution without hazards will also be equivalent.

\proof None of the claims in \S\ref{sec:proof:reorder} rely on commands being run not in parallel, so that proof still applies.

\subsection{Additional commands have no effect}
\label{sec:proof:additional}

\claim Given a script with no hazards when executed sequentially, speculating unnecessary commands will not affect the build's output.

\refutation This claim isn't actually true. As a counter example, \texttt{gcc -c main.c} gives one result, but running the additional command \texttt{echo 1 >> main.c} gives a different outcome. Therefore we strengthen the claim to:

\claim The above claim is true when unnecessary commands do not write to any inputs.

\proof Provided the inputs are unchanged, and there are no hazards, the proof from \S\ref{sec:proof:reorder} still applies.

We discuss the consequences and possible remediations in \S\ref{sec:choices}.

\begin{comment}

\subsection{No rebuilds}
\label{sec:proof:no_rebuild}

We prove that a build system with deterministic control logic and with no hazards always results in no rebuilds when no changes have occurred.

\begin{align}
  build :: \bar{command} \\
  command :: (cmd, reads :: \bar{file}, writes:: \bar{file}) \\
  file :: (name, content) \\
  eq(f1 :: file, f2 :: file) = name(f1) = name(f2) \&\& content(f1) = content(f2) \\
  hazard :: (file, command, command) \\
  files(command) = reads(command) \cup writes(command)
\end{align}

In a build system without hazards there is at most one write to any file, which occurs before any reads of that file. We can therefore prove there are no rebuilds by showing the first command can't rebuild, and proceeding by induction.

Let $B$ be a build with no hazards when executed sequentially.

\begin{description}
\item[Base case: $|B| = 1$]

  $\forall f \in reads(B[0]) \cup writes(B[0]), f \text{ has not changed}$, therefore, $B[0]$ does not run, and $\forall f \in writes(B[0])$ are not written to.

  % show that inputs of c = B[0] have not changed
  % therefore, c[0] will not run
  % therefore, the outputs of B, which are third(c[0]) will not have changed

\item[Induction step: $|B| = n+1$]
  Let us assume the above claim is true for a build, $|B| = n$.  Also, Let $D$ be the set of files written to during the build.
  It follows that, $\forall c \in B, \forall f \in writes(c), f \notin D$.
  Let us assume we have a build $A=B$, and $A$ has an extra command $A[n]=c1$.

  $\forall f \in files(c1), f \notin D, f \text{ has not changed}$, therefore, $A[n]$ does not run and $\forall f \in writes(A[n])$ are not written to.

\end{description}

\subsection{Reordered builds}
\label{sec:proof:reorder}

Given a script with no hazards when executed sequentially, we can show that any interleaving of those commands that also has no hazards will result in an equivalent output.

Let us assume we have a build $A$, with no hazards, meaning $\forall c = A[i] \in A, \forall f \in files(c), f \notin \bigcup^{|A|}_{j=i+1} writes(A[j])$.

Let us assume there exists a build $B$, that also has no hazards, meaning $\forall c = B[i] \in B, \forall f \in files(c), f \notin \bigcup^{|B|}_{j=i+1} writes(B[j])$.
Let us also assume that $|A|$ = $|B|$, and $\forall c \in A, \exists d \in B, s.t. cmd(c) = cmd(d)$.

Prove that $\forall c \in B, \exists d \in A, s.t. cmd(c) = cmd(d) \land reads(c) = reads(d) \implies writes(c) = writes(d) \implies \bigcup^{|B|}_{i=0} writes(B[i]) = \bigcup^{|A|}_{i=0} writes(A[i])$.

$\forall c = B[i] \in B, \forall f \in files(c), f \nexists d = B[j] \in B, s.t. i < j$

$\forall c \in B, \exists e = A[k] \in A, s.t. cmd(c) = cmd(e) \land \forall f \in files(c), \exists g \in files(e) \land \forall f \in files(e), \exists g \in files(c)$

$\implies \forall c \in B, \exists d \in A, s.t. cmd(c) = cmd(d) \land reads(c) = reads(d) \implies writes(c) = writes(d)$

$\implies \bigcup^{|B|}_{i=0} writes(B[i]) = \bigcup^{|A|}_{i=0} writes(A[i])$.
Therefore, for any script with no hazards when executed sequentially, any interleaving of those commands that also has no hazards will result in an equivalent output.

\subsection{Parallel commands}
\label{sec:proof:parallel}

Given a script with no hazards when executed sequentially, we can show that any parallel or interleaved execution without hazards will also be equivalent.

Proof by contradiction.

Let us assume we have a build $A$, which has no hazards.  Let us also assume there is an alternative execution of $A$, which has no hazards, but is not equivalent.
Recall that for the builds to be equivalent, they write to the same set of files and a file will have the same hash regardless of the build that wrote it.
Therefore, the parallel execution must write to a different set of files than $A$ or at least one of those files has a different hash.

\paragraph{Parallel build writes to a file $A$ does not write to, or $A$ writes to a file the parallel build does not write to.}
  There must exist a cmd $c$ which when run in parallel with one or more other commands, writes to a different set of files than when run sequentially.  The set of files written to by $c$ is affected by the content of the cmd, and the files it reads.  Since, the content of the cmd is the same between the parallel and sequential builds, the input files must differ.
  By the defintion of the parallel build of $A$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  Therefore, the files written by $c$ in the parallel build will be the same as the files written by $c$ in the sequential build.  Therefore, a contradiction.


\paragraph{Parallel build writes to a file $f$ whose hash is $h$ and $A$ writes to the same file but its hash is $k$; $h \neq k$}
  There must exist a cmd $c$ which when run in parallel with one or more other commands, writes to the file $f$ and produces the hash $h$ and when run sequentially in build $A$ produces the hash $k$.
  The files written to by $c$, and their hashes, is affected by the content of the command and the files read by the command.  Since $c$ is unchanged between $A$ the sequential run of $A$ and the parallel run of $A$, the files and their hashes read by $c$ must differ.  By the definition of parallel $A$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  And because parallel $A$ and sequential $A$ contain the same commands, $c$'s input must be the same regardless of whether $A$ was run in parallel or sequentially.  Therefore, a contradiction.

  % clean up

\subsection{Additional commands have no effect}
\label{sec:proof:additional}

Given a script with no hazards when executed sequentially, we can show that speculating unnecessary commands will not affect the build's output. % hmm

Proof by induction.

Let us assume we have a build $A$ which has no hazards when executed sequentially.

Base case:  Build $A$ has 1 command $c$.  Let us assume we have a command $d$ that does not write to any file read or written by $c$.  By this definition of $d$, it is obvious that $d$ running before or
concurrently with $c$ as part of build $A$, will not affect the files written by $c$ and therefore will not affect the output of $A$.

Inductive case: Let us assume the above claim is true for a build with $n$ commands.  Let us show the claim is true for a build of $n+1$ commands.

Let $A$ have $n+1$ command.  From the inductive hypothesis we know the output of the first $n$ commands is unchanged.  And, we know that $c$ does not write to any file read or written by command $n+1$.  And, because the build has no hazards, all files read by $n+1$ were written to before $n+1$ ran, so the output files of $n+1$ remain unchanged as well.  Therefore, the output of $A$ remained unaffected by $c$.
\end{comment}

\subsection{Classifying Hazards}
\label{sec:proof:classify_hazard}

% SS An explanation of the classification of hazards and a proof of the claims in 2.7

In section \S\ref{sec:speculation} we describe how speculation can be used to execute builds in parallel.  Speculation can lead to hazards that wouldn't have occurred if the build script was executed sequentially. Here we offer a more precise classification of hazards.

Aas per section \S\ref{sec:hazards}, hazards are first classified as either \emph{read-write} or \emph{write-write}.  A Hazard can be further classified by if and how a build can recover from it.

\paragraph{Non Recoverable}
A hazard is classified as \emph{non-recoverable} if it is triggered by a consistency violation in the build script.  A \emph{non-recoverable hazard} always results in the build terminating immediately with an error.  For two examples of \emph{non-recoverable hazards} see section \ref{sec:hazards}.

\paragraph{Recoverable}
A hazard is classified as \emph{recoverable} if it is caused by a speculated command that read a file which was concurrently or later written to by another command.  In this situation the speculated command likely read stale data and if re-executed would read up-to-date data.  Here is an example where \emph{cp foo.o baz.o} potentially copied the wrong version of \emph{foo.o} because it executed before \emph{gcc -c foo.c} completed.  If \emph{cp foo.o baz.o} re-executes it will read the new \emph{foo.o} produced by \emph{gcc -c foo.c}.

\begin{verbatim}
cp foo.o baz.o [speculate]
gcc -c foo.c
cp foo.o baz.o [re-execute]
\end{verbatim}

\paragraph{Proof that if the speculative read command of a \emph{recoverable} hazard is re-executed the same hazard will not re-occur.}

Let us assume there is a command $c$ which reads a file with the name $f$.  Let us assume there
is another command $d$ which writes to the file $f$.  It follows that if $d$ executes concurrently with or after $c$ that a \emph{read-write hazard}, $h$, involving the file $f$ would occur.

If $c$ were to execute again after $d$ terminated, by definition, the hazard $h$ cannot re-occur because the read of $f$ will have happened after the write of $f$.

\paragraph{Restartable} % when speculation causes a consistency violation. or a command to read incorrect data.
If a speculatively executed command wrote to a file that was later written to or read by another command, then incorrectness was potentiallly introduced to the build.  In a sequential build, it is a
consistency violation for any command to write to a file after a previous command has written to it, but it is ok for a command to read from a file that has previously been written to.  It isn't safe in this case, because if the speculated command wasn't supposed to run, it might have changed the contents of the file read by the later command.
The hazard might not have occurred in the speculated command wasn't run.  Therefore, if the build script was re-executed without the speculated command, the hazard might not re-occur.


%Proof that restartable hazard are handled
