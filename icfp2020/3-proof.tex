\section{Proofs}
\label{sec:proof}

The design of \Rattle relies on taking a sequence of commands and instead of running them all sequentially, rather running them in different orders. In this section we prove that the manipulations we perform are safe with respect to the reference semantics.

\subsection{Hazards, formally}

A hazard occurs when a Build command writes to a file that a previous command has already read from or written to.  Hazards can be classified as either: \emph{read-write hazards} or \emph{write-write hazards}.  In section \S\ref{sec:proof:classify_hazard} hazards are explained in greater detail, but for the following sections it suffices to say that in a build executed sequentially a
hazard occurs when a command read or writes a file and a later command writes to the same file.  In a build executed in parallel with speculation, a hazard can occur when a command reads or writes a file and a later command writes to the same file, or if two commands running concurrently access the same file and are not both just reading the file.  Therefore, for a sequential \Rattle build to have no hazards means for every command $c$ in the build, if $c$ reads or writes a file, no later command in the build will write to that file.  For a parallel \Rattle build to have no hazards means for every command $c$ in the build, if $c$ reads or writes a file, no later command will write to that file, and no command will concurrently read the file if it is being written, or write to the file if it is being read.

% SS seems this section should just be a brief explanation of hazards so the following claims of ``no hazards'' makes sense.

\subsection{No rebuilds}
\label{sec:proof:no_rebuild}

We prove that a build system with deterministic control logic and with no hazards always results in no rebuilds when no changes have occurred.

\begin{align}
  build :: \bar{command} \\
  command :: (cmd, reads :: \bar{file}, writes:: \bar{file}) \\
  file :: (name, content) \\
  eq(f1 :: file, f2 :: file) = name(f1) = name(f2) \&\& content(f1) = content(f2) \\
  hazard :: (file, command, command) \\
  files(command) = reads(command) \cup writes(command)
\end{align}

In a build system without hazards there is at most one write to any file, which occurs before any reads of that file. We can therefore prove there are no rebuilds by showing the first command can't rebuild, and proceeding by induction.

Let $B$ be a build with no hazards when executed sequentially.

\begin{description}
\item[Base case: $|B| = 1$]

  $\forall f \in reads(B[0]) \cup writes(B[0]), f \text{ has not changed}$, therefore, $B[0]$ does not run, and $\forall f \in writes(B[0])$ are not written to.

  % show that inputs of c = B[0] have not changed
  % therefore, c[0] will not run
  % therefore, the outputs of B, which are third(c[0]) will not have changed

\item[Induction step: $|B| = n+1$]
  Let us assume the above claim is true for a build, $|B| = n$.  Also, Let $D$ be the set of files written to during the build.
  It follows that, $\forall c \in B, \forall f \in writes(c), f \notin D$.
  Let us assume we have a build $A=B$, and $A$ has an extra command $A[n]=c1$.

  $\forall f \in files(c1), f \notin D, f \text{ has not changed}$, therefore, $A[n]$ does not run and $\forall f \in writes(A[n])$ are not written to.

\end{description}

\subsection{Reordered builds}
\label{sec:proof:reorder}

Given a script with no hazards when executed sequentially, we can show that any interleaving of those commands that also has no hazards will result in an equivalent output.

Let us assume we have a build $A$, with no hazards, meaning $\forall c = A[i] \in A, \forall f \in files(c), f \notin \bigcup^{|A|}_{j=i+1} writes(A[j])$.

Let us assume there exists a build $B$, that also has no hazards, meaning $\forall c = B[i] \in B, \forall f \in files(c), f \notin \bigcup^{|B|}_{j=i+1} writes(B[j])$.
Let us also assume that $|A|$ = $|B|$, and $\forall c \in A, \exists d \in B, s.t. cmd(c) = cmd(d)$.

Prove that $\forall c \in B, \exists d \in A, s.t. cmd(c) = cmd(d) \land reads(c) = reads(d) \implies writes(c) = writes(d) \implies \bigcup^{|B|}_{i=0} writes(B[i]) = \bigcup^{|A|}_{i=0} writes(A[i])$.

$\forall c = B[i] \in B, \forall f \in files(c), f \nexists d = B[j] \in B, s.t. i < j$

$\forall c \in B, \exists e = A[k] \in A, s.t. cmd(c) = cmd(e) \land \forall f \in files(c), \exists g \in files(e) \land \forall f \in files(e), \exists g \in files(c)$

$\implies \forall c \in B, \exists d \in A, s.t. cmd(c) = cmd(d) \land reads(c) = reads(d) \implies writes(c) = writes(d)$

$\implies \bigcup^{|B|}_{i=0} writes(B[i]) = \bigcup^{|A|}_{i=0} writes(A[i])$.
Therefore, for any script with no hazards when executed sequentially, any interleaving of those commands that also has no hazards will result in an equivalent output.

\subsection{Parallel commands}
\label{sec:proof:parallel}

Given a script with no hazards when executed sequentially, we can show that any parallel or interleaved execution without hazards will also be equivalent.

Proof by contradiction.

Let us assume we have a build $A$, which has no hazards.  Let us also assume there is an alternative execution of $A$, which has no hazards, but is not equivalent.
Recall that for the builds to be equivalent, they write to the same set of files and a file will have the same hash regardless of the build that wrote it.
Therefore, the parallel execution must write to a different set of files than $A$ or at least one of those files has a different hash.

\paragraph{Parallel build writes to a file $A$ does not write to, or $A$ writes to a file the parallel build does not write to.}
  There must exist a cmd $c$ which when run in parallel with one or more other commands, writes to a different set of files than when run sequentially.  The set of files written to by $c$ is affected by the content of the cmd, and the files it reads.  Since, the content of the cmd is the same between the parallel and sequential builds, the input files must differ.
  By the defintion of the parallel build of $A$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  Therefore, the files written by $c$ in the parallel build will be the same as the files written by $c$ in the sequential build.  Therefore, a contradiction.


\paragraph{Parallel build writes to a file $f$ whose hash is $h$ and $A$ writes to the same file but its hash is $k$; $h \neq k$}
  There must exist a cmd $c$ which when run in parallel with one or more other commands, writes to the file $f$ and produces the hash $h$ and when run sequentially in build $A$ produces the hash $k$.
  The files written to by $c$, and their hashes, is affected by the content of the command and the files read by the command.  Since $c$ is unchanged between $A$ the sequential run of $A$ and the parallel run of $A$, the files and their hashes read by $c$ must differ.  By the definition of parallel $A$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  And because parallel $A$ and sequential $A$ contain the same commands, $c$'s input must be the same regardless of whether $A$ was run in parallel or sequentially.  Therefore, a contradiction.

  % clean up

\subsection{Additional commands have no effect}
\label{sec:proof:additional}

Given a script with no hazards when executed sequentially, we can show that speculating unnecessary commands will not affect the build's output. % hmm

Proof by induction.

Let us assume we have a build $A$ which has no hazards when executed sequentially.

Base case:  Build $A$ has 1 command $c$.  Let us assume we have a command $d$ that does not write to any file read or written by $c$.  By this definition of $d$, it is obvious that $d$ running before or
concurrently with $c$ as part of build $A$, will not affect the files written by $c$ and therefore will not affect the output of $A$.

Inductive case: Let us assume the above claim is true for a build with $n$ commands.  Let us show the claim is true for a build of $n+1$ commands.

Let $A$ have $n+1$ command.  From the inductive hypothesis we know the output of the first $n$ commands is unchanged.  And, we know that $c$ does not write to any file read or written by command $n+1$.  And, because the build has no hazards, all files read by $n+1$ were written to before $n+1$ ran, so the output files of $n+1$ remain unchanged as well.  Therefore, the output of $A$ remained unaffected by $c$.

\subsection{Classifying Hazards}
\label{sec:proof:classify_hazard}

% SS An explanation of the classification of hazards and a proof of the claims in 2.7

In section \S\ref{sec:speculation} we describe how speculation can be used to execute builds in parallel.  Sometimes when commands are speculated, hazards can occur that wouldn't have if the build script was executed sequentially.  In that section we describe when speculation can lead to hazards and how they can be recovered from.  Here we offer a more precise classification of those hazards and proofs related to them.

Hazards are first classified as either \emph{read-write} or \emph{write-write}.  Hazards can be further classified by how the hazard occurred.

\paragraph{Non Recoverable}
A hazard is classified as \emph{non-recoverable} if it is triggered by a consistency violation in the build script.  A \emph{non-recoverable hazard} always results in the build terminating immediately with an error.  For two examples of \emph{non-recoverable hazards} see section \ref{sec:hazards}.

\paragraph{Recoverable}
A hazard is classified as \emph{recoverable} if it is caused by a speculated command that read a file which was concurrently or later written to by another command.  In this situation the speculated command likely read stale data and if re-executed would read up-to-date data.  Here is an example where \emph{cp foo.o baz.o} potentially copied the wrong version of \emph{foo.o} because it executed before \emph{gcc -c foo.c} completed.  If \emph{cp foo.o baz.o} re-executes it will read the new \emph{foo.o} produced by \emph{gcc -c foo.c}.

\begin{verbatim}
cp foo.o baz.o [speculate]
gcc -c foo.c
cp foo.o baz.o [re-execute]
\end{verbatim}

Proof that if the read command of a \emph{recoverable} hazard is re-executed the same hazard will not re-occur.

% SS todo above proof

\paragraph{Restartable} % when speculation causes a consistency violation. or a command to read incorrect data.
If a speculatively executed command wrote to a file that was later written to or read by another command, then incorrectness was potentially introduced into the build.  In the following example \emph{cp foo.o baz.o} was speculated, and wrote to \emph{baz.o}, then \emph{gcc -c baz.c} was executed and also wrote to \emph{baz.o}.  Normally a build script that executed these two commands would violate \Rattle's consistency properties, but in this case the consistency violation might have been avoided if \emph{cp foo.o baz.o} were not executed by the build.  Therefore, if the build script was re-executed and did not speculate \emph{cp foo.o baz.o} then the consistency violation might not occur.

\begin{verbatim}
cp foo.o baz.o [speculate]
gcc -c baz.c
\end{verbatim}

Another possible situation is \Rattle executing something like the following:

\begin{verbatim}
cp old-foo.c foo.c [speculate]
gcc -c foo.c
\end{verbatim}

Maybe the build script originally included \emph{cp old-foo.c foo.c}, but it was removed in the most recent version of the build.  By speculating this old command the build caused \emph{gcc -c foo.c} to
potentially build the wrong \emph{foo.c}.  If the build  were to re-execute and not speculate \emph{cp old-foo.c foo.c} then \emph{gcc -c foo.c} would build the correct \emph{foo.c} during the next build.  % This is a bad example since Rattle would have corrupted foo.c with the bad copy.  Need a new example or address this

%Proof that restartable hazard are handled
