\section{Proofs}
\label{sec:proof}

\subsection{Hazards, formally}

A hazard occurs when a Build command writes to a file that a previous command has already read from or written to.  Hazards can be classified as either: \emph{read-write hazards} or \emph{write-write hazards}.  In section \S\ref{sec:proof:classify_hazards} hazards are explained in greater detail.  For the following sections though it suffices to say that in a build being executed sequentially a
hazard occurs when a command read or writes a file and a later command writes to the same file.  In a build being executed in parallel with speculation, a hazard can occur when a command reads or writes a file and a later command writes to the same file, or if two commands running concurrently access the same file and are not both just reading the file.  Therefore, for a sequential \Rattle build to have no hazards means for every command $c$ in the build, if $c$ reads or writes a file, no later command will write to that file.  For a parallel \Rattle build to have no hazards means for every command $c$ in the build, if $c$ reads or writes a file, no later command will write to that file, and no command will concurrently read the file if it is being written, or write to the file if it is being read.

% SS seems this section should just be a brief explanation of hazards so the following claims of ``no hazards'' makes sense.

\subsection{No rebuilds}
\label{sec:proof:no_rebuild}

We prove that a build system with deterministic control logic with no hazards always results in no rebuilds.
In a build system without hazards there is at most one write to any file, which occurs before any reads of that file. We can therefore prove there are no rebuilds by showing the first command can't rebuild, and proceeding by induction.

Let us have a build of \emph{n} commands that meets the above restrictions.  

Base case: Command $1$ of $1$  will not be re-run because from the definition of the claim none of its inputs has changed, and the build system's control logic is deterministic.  Because, command $1$ is not re-running, it will not write to any files.  

Induction step:  Let us assume the above claim is true for a build with $n$ commands.  Let us show the claim is true for a build of $n+1$ commands.

If the first $n$ commands of the build did not run and did not write to any files, then the dependencies of command $n+1$ could not have changed during the build, and from the claim above we know they did not change before the build, therefore, command $n+1$ will not run.

\subsection{Reordered builds}
\label{sec:proof:reorder}

Given a script with no hazards when executed sequentially, we can show that any interleaving of those commands that also has no hazards will result in an equivalent output.

Proof by contradiction.

Let us assume we have a build script $A$, with no hazards.  Let us also assume there exists a build script $B$, which is an alternative ordering of the build script $A$, which also has no hazards and produces an output different from the output produced by $A$.  Here, the output of a build script is the set of files written and their hashes.

Therefore, $B$ produces a different set of file and hashes than $A$ does when running the same set of commands.

\begin{description}
\item [$B$ writes to a file $A$ does not write to. Or $A$ writes to a file $B$ does not write to]
  There must exist a cmd $c$ which when run by $A$ and $B$ writes to a different set of files.  The set of files written to by $c$ is affected by the content of the cmd, and the set of input files.  Since, the content of the cmd is the same between $A$ and $B$, the input files must differ.

  By the definition of $A$ and $B$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build. And because $A$ and $B$ contain the same commands, $c$'s input files must be the same regardless of build.  Therefore, a contradiction.

\item [$B$ writes to a file $f$ whose hash is $h$ and $A$ writes to the same file but its hash is $K$; $h \neq k$]
  There must exist a cmd $c$ which when run by $A$ and $B$ writes to the file $f$ and produces the different hashes, $k$ and $h$ respectively.  The files written to by $c$ is affected by the content of the cmd and the set of input files. Since $c$ is the same between $A$ and $B$, the input files must differ.

  By the definition of $A$ and $B$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  And because $A$ and $B$ contain the same commands, $c$'s input files must be the same regardless of build.  Therefore, a contradiction.
  
\end{description}

\subsection{Parallel commands}
\label{sec:proof:parallel}

Given a script with no hazards when executed sequentially, we can show that any parallel or interleaved execution without hazards will also be equivalent.

Proof by contradiction.

Let us assume we have a build $A$, which has no hazards.  Let us also assume there is an alternative execution of $A$, which has no hazards, but is not equivalent.
Recall that for the builds to be equivalent, they write to the same set of files and a file will have the same hash regardless of the build that wrote it.
Therefore, the parallel execution must write to a different set of files than $A$ or at least one of those files has a different hash.

\begin{description}
\item [parallel build writes to a file $A$ does not write to, or $A$ writes to a file the parallel build does not write to.]
  There must exist a cmd $c$ which when run in parallel with one or more other commands, writes to a different set of files than when run sequentially.  The set of files written to by $c$ is affected by the content of the cmd, and the files it reads.  Since, the content of the cmd is the same between the parallel and sequential builds, the input files must differ.
  By the defintion of the parallel build of $A$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  Therefore, the files written by $c$ in the parallel build will be the same as the files written by $c$ in the sequential build.  Therefore, a contradiction.

  
\item [parallel build writes to a file $f$ whose hash is $h$ and $A$ writes to the same file but its hash is $k$; $h \neq k$]
  There must exist a cmd $c$ which when run in parallel with one or more other commands, writes to the file $f$ and produces the hash $h$ and when run sequentially in build $A$ produces the hash $k$.
  The files written to by $c$, and their hashes, is affected by the content of the command and the files read by the command.  Since $c$ is unchanged between $A$ the sequential run of $A$ and the parallel run of $A$, the files and their hashes read by $c$ must differ.  By the definition of parallel $A$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  And because parallel $A$ and sequential $A$ contain the same commands, $c$'s input must be the same regardless of whether $A$ was run in parallel or sequentially.  Therefore, a contradiction.

  % clean up
\end{description}

\subsection{Additional commands have no effect}
\label{sec:proof:additional}

Given a script with no hazards when executed sequentially, we can show that speculating unnecessary commands will not affect the build's output. % hmm

Proof by induction.

Let us assume we have a build $A$ which has no hazards when executed sequentially.

Base case:  Build $A$ has 1 command $c$.  Let us assume we have a command $d$ that does not write to any file read or written by $c$.  By this definition of $d$, it is obvious that $d$ running before or
concurrently with $c$ as part of build $A$, will not affect the files written by $c$ and therefore will not affect the output of $A$.

Inductive case: Let us assume the above claim is true for a build with $n$ commands.  Let us show the claim is true for a build of $n+1$ commands.

Let $A$ have $n+1$ command.  From the inductive hypothesis we know the output of the first $n$ commands is unchanged.  And, we know that $c$ does not write to any file read or written by command $n+1$.  And, because the build has no hazards, all files read by $n+1$ were written to before $n+1$ ran, so the output files of $n+1$ remain unchanged as well.  Therefore, the output of $A$ remained unaffected by $c$.

\subsection{Classifying Hazards}
\label{sec:proof:classify_hazard}

% SS An explanation of the classification of hazards and a proof of the claims in 2.7

In section \S\ref{sec:speculation} we describe how \Rattle uses speculation to execute builds in parallel.  Sometimes when \Rattle speculates commands, hazards can occur that wouldn't have if the build script was executed sequentially.  In that section we mention when speculation can lead to hazards and what \Rattle can do to recover from them.  Here we offer a more precise classification of othose hazards and proofs that \Rattle's actions recovering from them does not change the outcome of the build.

Hazards are first classified as either \emph{read-write} or \emph{write-write}.  Hazards can be further classified by how and if \Rattle can recover from the hazard.  

\paragraph{Non Recoverable}
A hazard is classified as \emph{non-recoverable} if it is triggered by a consistency violation in the build script.  A \emph{non-recoverable hazard} always results in the build terminating immediateley with an error.  For two examples of \emph{non-recoverable hazards} see section \ref{sec:hazards}.

\paragraph{Recoverable}
A hazard is classified as \emph{recoverable} if it is caused by \Rattle speculating a command which read a file concurrently or later written to by another command.  In this situation the speculated command likely read stale data and if re-executed would read up-to-date data.  Here is an example where \emph{cp foo.o baz.o} potentially copied the wrong version of \emph{foo.o} because it executed before \emph{gcc -c foo.c} completed.  If \emph{cp foo.o baz.o} re-executes it will read the new \emph{foo.o} produced by \emph{gcc -c foo.c}.  

\begin{verbatim}
cp foo.o baz.o [speculate]
gcc -c foo.c
cp foo.o baz.o [re-execute]
\end{verbatim}

Proof that \Rattle will produce an equivalent outcome to executing the build script sequentially if it re-executes the speculative read command of a \emph{recoverable read-write hazard}.

% proving that when a recoverable read-write hazard occurs the build outcome when re-executing the
% failed read will be the same as if the build was executed sequentially

% have a build A which when executed sequentially either results in a non-recoverable hazard
% or produces an output of a set of files with certain hashes

% prove that if rattle is speculating commands and there is a recoerable read write hazard
% that it can re-execute the read command and will still produce an outcome equivalent

% aka will prodcue a non-recoverable hazard ( do we care which one?) I say no
% produce the same set of output files with the same hashes

% SS writing this about the alternative scheduler I wrote since it doesn't really apply to the
%    original one. can be removed if it isnt relevant
Let us assume we have a build $A$ which when executed sequentially produces an output $O$.
There are two possible outputs:
\begin{description}
\item [Non-recoverable hazard] Proof by contradiction.
  Let us assume \Rattle executes commands speculatively and a \emph{recoverable read-write hazard} occurs.  All \emph{read-write hazards} are made up of two commands, $c1$, the command which read the file, and $c2$, the command which wrote to the file. In this case we also know $c1$ was executed speculatively.
  
  
\item [writes to set of files $F$]
\end{description}






% Proof that Rattle can re-execute the read portion of a recoverable hazard
A recoverable hazard is made up of two commands, $c1$ and $c2$, where $c1$ reads one or more files written by $c2$, and $c2$ does not read or write to any files written by $c1$.  Additionally, $c1$ ran before or at the same time as $c2$.  Because, $c1$ does not write to any files read or written to by $c2$, executing $c1$ again after $c2$ terminates will never cause $c2$ to need to rebuild.

% State something about re-executing c1 causing new hazards.
After re-executing $c1$ there is the possibility of a new hazard occuring. 
\begin{description}
\item[hazard] The new hazard will be handled in the same manner as already described.
\item[no hazard] The build continues.
\end{description}

\paragraph{Restartable} % when speculation causes a consistency violation. or a command to read incorrect data.
If \Rattle speculatively executed a command that wrote to a file that was later written to or read by another command, then incorrectness was potentially introduced into the build.  In the following example \emph{cp foo.o baz.o} was speculated, and wrote to \emph{baz.o}, then \emph{gcc -c baz.c} was executed and also wrote to \emph{baz.o}.  Normally a build script that executed these two commands would violate \Rattle's consistency properties, but in this case the consistency violation might have been avoided if \emph{cp foo.o baz.o} were not executed by the build.  Therefore, if \Rattle were to re-execute the build script and not speculate \emph{cp foo.o baz.o} then the consistency violation might not occur.

\begin{verbatim}
cp foo.o baz.o [speculate]
gcc -c baz.c
\end{verbatim}

Another possible situation is \Rattle executing something like the following:

\begin{verbatim}
cp old-foo.c foo.c [speculate]
gcc -c foo.c
\end{verbatim}

Maybe the build script originally included \emph{cp old-foo.c foo.c}, but it was removed in the most recent version of the build.  By speculating this old command \Rattle caused \emph{gcc -c foo.c} to
potentially build the wrong \emph{foo.c}.  If \Rattle were to re-execute the build and not speculate \emph{cp old-foo.c foo.c} then \emph{gcc -c foo.c} would build the correct \emph{foo.c} during the next build.  % This is a bad example since Rattle would have corrupted foo.c with the bad copy.  Need a new example or address this

%Proof that restartable hazard are handled


