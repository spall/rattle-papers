\section{Proofs}
\label{sec:proof}

\subsection{Hazards, formally}

A hazard occurs when a Build command writes to a file that a previous command has already read from or written to.  So, hazards can be classified as either: \emph{read-write hazards} or \emph{write-write hazards}.  

\subsection{No rebuilds}
\label{sec:proof:no_rebuild}

We prove that a build system with deterministic control logic with no hazards always results in no rebuilds.
In a build system without hazards there is at most one write to any file, which occurs before any reads of that file. We can therefore prove there are no rebuilds by showing the first command can't rebuild, and proceeding by induction.

Let us have a build of \emph{n} commands that meets the above restrictions.  

Base case: Command $1$ of $1$  will not be re-run because from the definition of the claim none of its inputs has changed, and the build system's control logic is deterministic.  Because, command $1$ is not re-running, it will not write to any files.  

Induction step:  Let us assume the above claim is true for a build with $n$ commands.  Let us show the claim is true for a build of $n+1$ commands.

If the first $n$ commands of the build did not run and did not write to any files, then the dependencies of command $n+1$ could not have changed during the build, and from the claim above we know they did not change before the build, therefore, command $n+1$ will not run.

\subsection{Reordered builds}
\label{sec:proof:reorder}

Given a script with no hazards when executed sequentially, we can show that any interleaving of those commands that also has no hazards will result in an equivalent output.

Proof by contradiction.

Let us assume we have a build script $A$, with no hazards.  Let us also assume there exists a build script $B$, which is an alternative ordering of the build script $A$, which also has no hazards and produces an output different from the output produced by $A$.  Here, the output of a build script is the set of files written and their hashes.

Therefore, $B$ produces a different set of file and hashes than $A$ does when running the same set of commands.

\begin{description}
\item [$B$ writes to a file $A$ does not write to. Or $A$ writes to a file $B$ does not write to]
  There must exist a cmd $c$ which when run by $A$ and $B$ writes to a different set of files.  The set of files written to by $c$ is affected by the content of the cmd, and the set of input files.  Since, the content of the cmd is the same between $A$ and $B$, the input files must differ.

  By the definition of $A$ and $B$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build. And because $A$ and $B$ contain the same commands, $c$'s input files must be the same regardless of build.  Therefore, a contradiction.

\item [$B$ writes to a file $f$ whose hash is $h$ and $A$ writes to the same file but its hash is $K$; $h \neq k$]
  There must exist a cmd $c$ which when run by $A$ and $B$ writes to the file $f$ and produces the different hashes, $k$ and $h$ respectively.  The files written to by $c$ is affected by the content of the cmd and the set of input files. Since $c$ is the same between $A$ and $B$, the input files must differ.

  By the definition of $A$ and $B$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  And because $A$ and $B$ containt he same commands, $c$'s input files must be the same regardless of build.  Therefore, a contradiction.
  
\end{description}

\subsection{Parallel commands}
\label{sec:proof:parallel}

Given a script with no hazards when executed sequentially, we can show it is safe to execute commands that only read the same files in parallel.

% This seems so obvious i'm not sure how to ``prove'' it.


\subsection{Additional commands have no effect}
\label{sec:proof:additional}

Given a script with no hazards when executed sequentially, we can show that speculating unnecessary commands will not affect the build's output. % hmm

Let us assume we have a build $A$ which has $n$ commands, $c1$ to $cn$.  Let us assume there is a command $d1$, which is not a member of $A$.  Let us also assume it does not write to any file read by any command in $A$.  Then \Rattle can safely execute $d1$ concurrently with $c1$ through $cn$ without affecting the build's output.

% I think I missed the point here.

\subsection{Classifying Hazards}
\label{sec:proof:classify_hazard}

Hazards are first classified as either \emph{read-write} or \emph{write-write}.  The command execution that led to the hazard classifies it further.

\paragraph{Non Recoverable}
Commands in the build script when executed sequentially violate the consistency rules in \ref{sec:hazards}.  A non-recoverable hazard results in \Rattle terminating the build immediately with an error.  See the two examples from \ref{sec:hazards}.


\paragraph{Recoverable}
Speculatively executed command(s) read file(s) which were later written to during the build.  If \Rattle speculatively executed a command which read from a file which was later written to, that command
probably read stale data.  \Rattle can re-execute the speculatively executed command with no loss of correctness.

\begin{verbatim}
cp foo.o baz.o [speculate]
gcc -c foo.c
cp foo.o baz.o [re-execute]
\end{verbatim}

% Proof that Rattle can re-execute the read portion of a recoverable hazard
A recoverable hazard is made up of two commands, $c1$ and $c2$, where $c1$ reads one or more files written by $c2$, and $c2$ does not read or write to any files written by $c1$.  Additionally, $c1$ ran before or at the same time as $c2$.  Because, $c1$ does not write to any files read or written to by $c2$, executing $c1$ again after $c2$ terminates will never cause $c2$ to need to rebuild.

% State something about re-executing c1 causing new hazards.
After re-executing $c1$ there is the possibility of a new hazard occuring. 
\begin{description}
\item[hazard] The new hazard will be handled in the same manner as already described.
\item[no hazard] The build continues.
\end{description}

\paragraph{Restartable} % when speculation causes a consistency violation. or a command to read incorrect data.
If \Rattle speculatively executed a command that wrote to a file that was later written to or read by another command, then incorrectness was potentially introduced into the build.  In the following example \emph{cp foo.o baz.o} was speculated, and wrote to \emph{baz.o}, then \emph{gcc -c baz.c} was executed and also wrote to \emph{baz.o}.  Normally a build script that executed these two commands would violate \Rattle's consistency properties, but in this case the consistency violation might have been avoided if \emph{cp foo.o baz.o} were not executed by the build.  Therefore, if \Rattle were to re-execute the build script and not speculate \emph{cp foo.o baz.o} then the consistency violation might not occur.

\begin{verbatim}
cp foo.o baz.o [speculate]
gcc -c baz.c
\end{verbatim}

Another possible situation is \Rattle executing something like the following:

\begin{verbatim}
cp old-foo.c foo.c [speculate]
gcc -c foo.c
\end{verbatim}

Maybe the build script originally included \emph{cp old-foo.c foo.c}, but it was removed in the most recent version of the build.  By speculating this old command \Rattle caused \emph{gcc -c foo.c} to
potentially build the wrong \emph{foo.c}.  If \Rattle were to re-execute the build and not speculate \emph{cp old-foo.c foo.c} then \emph{gcc -c foo.c} would build the correct \emph{foo.c} during the next build.  % This is a bad example since Rattle would have corrupted foo.c with the bad copy.  Need a new example or address this

%Proof that restartable hazard are handled


