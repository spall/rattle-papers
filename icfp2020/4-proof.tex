\section{Proofs}
\label{sec:proof}

The design of \Rattle relies on taking a sequence of commands and instead of running them all sequentially, instead running different commands in different orders. In this section we prove that the manipulations we perform are safe with respect to the reference semantics.

\subsection{Hazards, formally}

A hazard occurs when a Build command writes to a file that a previous command has already read from or written to.  Hazards can be classified as either: \emph{read-write hazards} or \emph{write-write hazards}.  In section \S\ref{sec:proof:classify_hazards} hazards are explained in greater detail.  For the following sections though it suffices to say that in a build being executed sequentially a
hazard occurs when a command read or writes a file and a later command writes to the same file.  In a build being executed in parallel with speculation, a hazard can occur when a command reads or writes a file and a later command writes to the same file, or if two commands running concurrently access the same file and are not both just reading the file.  Therefore, for a sequential \Rattle build to have no hazards means for every command $c$ in the build, if $c$ reads or writes a file, no later command will write to that file.  For a parallel \Rattle build to have no hazards means for every command $c$ in the build, if $c$ reads or writes a file, no later command will write to that file, and no command will concurrently read the file if it is being written, or write to the file if it is being read.

% SS seems this section should just be a brief explanation of hazards so the following claims of ``no hazards'' makes sense.

\subsection{No rebuilds}
\label{sec:proof:no_rebuild}

We prove that a build system with deterministic control logic with no hazards always results in no rebuilds.
In a build system without hazards there is at most one write to any file, which occurs before any reads of that file. We can therefore prove there are no rebuilds by showing the first command can't rebuild, and proceeding by induction.

Let us have a build of \emph{n} commands that meets the above restrictions.

Base case: Command $1$ of $1$  will not be re-run because from the definition of the claim none of its inputs has changed, and the build system's control logic is deterministic.  Because, command $1$ is not re-running, it will not write to any files.

Induction step:  Let us assume the above claim is true for a build with $n$ commands.  Let us show the claim is true for a build of $n+1$ commands.

If the first $n$ commands of the build did not run and did not write to any files, then the dependencies of command $n+1$ could not have changed during the build, and from the claim above we know they did not change before the build, therefore, command $n+1$ will not run.

\subsection{Reordered builds}
\label{sec:proof:reorder}

Given a script with no hazards when executed sequentially, we can show that any interleaving of those commands that also has no hazards will result in an equivalent output.

Proof by contradiction.

Let us assume we have a build script $A$, with no hazards.  Let us also assume there exists a build script $B$, which is an alternative ordering of the build script $A$, which also has no hazards and produces an output different from the output produced by $A$.  Here, the output of a build script is the set of files written and their hashes.

Therefore, $B$ produces a different set of file and hashes than $A$ does when running the same set of commands.

\begin{description}
\item [$B$ writes to a file $A$ does not write to. Or $A$ writes to a file $B$ does not write to]
  There must exist a cmd $c$ which when run by $A$ and $B$ writes to a different set of files.  The set of files written to by $c$ is affected by the content of the cmd, and the set of input files.  Since, the content of the cmd is the same between $A$ and $B$, the input files must differ.

  By the definition of $A$ and $B$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build. And because $A$ and $B$ contain the same commands, $c$'s input files must be the same regardless of build.  Therefore, a contradiction.

\item [$B$ writes to a file $f$ whose hash is $h$ and $A$ writes to the same file but its hash is $K$; $h \neq k$]
  There must exist a cmd $c$ which when run by $A$ and $B$ writes to the file $f$ and produces the different hashes, $k$ and $h$ respectively.  The files written to by $c$ is affected by the content of the cmd and the set of input files. Since $c$ is the same between $A$ and $B$, the input files must differ.

  By the definition of $A$ and $B$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  And because $A$ and $B$ contain the same commands, $c$'s input files must be the same regardless of build.  Therefore, a contradiction.

\end{description}

\subsection{Parallel commands}
\label{sec:proof:parallel}

Given a script with no hazards when executed sequentially, we can show that any parallel or interleaved execution without hazards will also be equivalent.

Proof by contradiction.

Let us assume we have a build $A$, which has no hazards.  Let us also assume there is an alternative execution of $A$, which has no hazards, but is not equivalent.
Recall that for the builds to be equivalent, they write to the same set of files and a file will have the same hash regardless of the build that wrote it.
Therefore, the parallel execution must write to a different set of files than $A$ or at least one of those files has a different hash.

\begin{description}
\item [parallel build writes to a file $A$ does not write to, or $A$ writes to a file the parallel build does not write to.]
  There must exist a cmd $c$ which when run in parallel with one or more other commands, writes to a different set of files than when run sequentially.  The set of files written to by $c$ is affected by the content of the cmd, and the files it reads.  Since, the content of the cmd is the same between the parallel and sequential builds, the input files must differ.
  By the defintion of the parallel build of $A$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  Therefore, the files written by $c$ in the parallel build will be the same as the files written by $c$ in the sequential build.  Therefore, a contradiction.


\item [parallel build writes to a file $f$ whose hash is $h$ and $A$ writes to the same file but its hash is $k$; $h \neq k$]
  There must exist a cmd $c$ which when run in parallel with one or more other commands, writes to the file $f$ and produces the hash $h$ and when run sequentially in build $A$ produces the hash $k$.
  The files written to by $c$, and their hashes, is affected by the content of the command and the files read by the command.  Since $c$ is unchanged between $A$ the sequential run of $A$ and the parallel run of $A$, the files and their hashes read by $c$ must differ.  By the definition of parallel $A$ having no hazards, any files read by $c$ must be written to by commands that precede $c$ in the build.  And because parallel $A$ and sequential $A$ contain the same commands, $c$'s input must be the same regardless of whether $A$ was run in parallel or sequentially.  Therefore, a contradiction.

  % clean up
\end{description}



\subsection{Additional commands have no effect}
\label{sec:proof:additional}

Given a script with no hazards when executed sequentially, we can show that speculating unnecessary commands will not affect the build's output. % hmm

Proof by induction.

Let us assume we have a build $A$ which has no hazards when executed sequentially.

Base case:  Build $A$ has 1 command $c$.  Let us assume we have a command $d$ that does not write to any file read or written by $c$.  By this definition of $d$, it is obvious that $d$ running before or
concurrently with $c$ as part of build $A$, will not affect the files written by $c$ and therefore will not affect the output of $A$.

Inductive case: Let us assume the above claim is true for a build with $n$ commands.  Let us show the claim is true for a build of $n+1$ commands.

Let $A$ have $n+1$ command.  From the inductive hypothesis we know the output of the first $n$ commands is unchanged.  And, we know that $c$ does not write to any file read or written by command $n+1$.  And, because the build has no hazards, all files read by $n+1$ were written to before $n+1$ ran, so the output files of $n+1$ remain unchanged as well.  Therefore, the output of $A$ remained unaffected by $c$.

\subsection{Classifying Hazards}
\label{sec:proof:classify_hazard}

Hazards are first classified as either \emph{read-write} or \emph{write-write}.  The command execution that led to the hazard classifies it further.

\paragraph{Non Recoverable}
Commands in the build script when executed sequentially violate the consistency rules in \ref{sec:hazards}.  A non-recoverable hazard results in \Rattle terminating the build immediately with an error.  See the two examples from \ref{sec:hazards}.


\paragraph{Recoverable}
Speculatively executed command(s) read file(s) which were later written to during the build.  If \Rattle speculatively executed a command which read from a file which was later written to, that command
probably read stale data.  \Rattle can re-execute the speculatively executed command with no loss of correctness.

\begin{verbatim}
cp foo.o baz.o [speculate]
gcc -c foo.c
cp foo.o baz.o [re-execute]
\end{verbatim}

% Proof that Rattle can re-execute the read portion of a recoverable hazard
A recoverable hazard is made up of two commands, $c1$ and $c2$, where $c1$ reads one or more files written by $c2$, and $c2$ does not read or write to any files written by $c1$.  Additionally, $c1$ ran before or at the same time as $c2$.  Because, $c1$ does not write to any files read or written to by $c2$, executing $c1$ again after $c2$ terminates will never cause $c2$ to need to rebuild.

% State something about re-executing c1 causing new hazards.
After re-executing $c1$ there is the possibility of a new hazard occuring.
\begin{description}
\item[hazard] The new hazard will be handled in the same manner as already described.
\item[no hazard] The build continues.
\end{description}

\paragraph{Restartable} % when speculation causes a consistency violation. or a command to read incorrect data.
If \Rattle speculatively executed a command that wrote to a file that was later written to or read by another command, then incorrectness was potentially introduced into the build.  In the following example \emph{cp foo.o baz.o} was speculated, and wrote to \emph{baz.o}, then \emph{gcc -c baz.c} was executed and also wrote to \emph{baz.o}.  Normally a build script that executed these two commands would violate \Rattle's consistency properties, but in this case the consistency violation might have been avoided if \emph{cp foo.o baz.o} were not executed by the build.  Therefore, if \Rattle were to re-execute the build script and not speculate \emph{cp foo.o baz.o} then the consistency violation might not occur.

\begin{verbatim}
cp foo.o baz.o [speculate]
gcc -c baz.c
\end{verbatim}

Another possible situation is \Rattle executing something like the following:

\begin{verbatim}
cp old-foo.c foo.c [speculate]
gcc -c foo.c
\end{verbatim}

Maybe the build script originally included \emph{cp old-foo.c foo.c}, but it was removed in the most recent version of the build.  By speculating this old command \Rattle caused \emph{gcc -c foo.c} to
potentially build the wrong \emph{foo.c}.  If \Rattle were to re-execute the build and not speculate \emph{cp old-foo.c foo.c} then \emph{gcc -c foo.c} would build the correct \emph{foo.c} during the next build.  % This is a bad example since Rattle would have corrupted foo.c with the bad copy.  Need a new example or address this

%Proof that restartable hazard are handled


