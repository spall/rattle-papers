\section{Introduction}
\label{sec:introduction}

Build scripts \cite{build_systems_a_la_carte} describe \emph{commands to run} and \emph{dependencies to respect}. For example, using the \Make build system, a build script might look like:

\vspace{3mm}
\begin{verbatim}
main.o: main.c
    gcc -c main.c
util.o: util.c
    gcc -c util.c
main.exe: main.o util.o
    gcc -o main.exe main.o util.o
\end{verbatim}
\vspace{3mm}

This script contains three rules -- taking a look at the first, it says \texttt{main.o} depends on \texttt{main.c}, and is produced by running \texttt{gcc -c main.c}. But what if we copied just the commands into a shell script? We get:

\vspace{3mm}
\begin{verbatim}
gcc -c main.c
gcc -c util.c
gcc -o main.exe main.o util.o
\end{verbatim}
\vspace{3mm}

That's shorter, simpler and easier to follow. Instead of declaring the outputs and dependencies of each command, we've merely given one valid ordering of the commands (we could equally have put \texttt{gcc -c util.c} first). There are two main downsides: 1) everything will always rebuild even if it's dependencies haven't changed; 2) the commands will run sequentially, while \Make can run the two \texttt{gcc -c} commands in parallel. But there are some benefits. We've fixed an inadvertent bug -- these commands depend on the undeclared dependency \texttt{gcc}, and potentially whatever header files are used by \texttt{main.c} and \texttt{util.c}. Furthermore, as the files \texttt{main.c} and \texttt{util.c} evolve, and their dependencies change (by changing the \texttt{\#include} directives), the shell script remains correct, while the \Make script \emph{must} be kept consistent (or builds will become stagnant).

\subsection{Overview}

In this paper we show how to take the above shell script and gain the benefits of a \Make script (\S\ref{sec:design}). Firstly, we can skip those commands whose dependencies haven't changed by \emph{tracing} which files are read/written by each command and using that information to detect and skip those commands whose result wouldn't change (\S\ref{sec:skipping_unnecessary}). Secondly, we can run some commands in parallel, using \emph{speculation} to guess at which commands are likely to come next and won't interfere with things already running (\S\ref{sec:speculation}). The key to speculation is a robust model of what ``interfering'' means -- we call a problematic interference a \emph{hazard}, which we define in \S\ref{sec:hazards} and use to prove important properties about the safety of speculation in \S\ref{sec:proof}.

We have implemented these techniques in a build system called \Rattle\footnote{\url{https://github.com/author_name_omitted/rattle}}, introduced in \S\ref{sec:implementation}, which embeds commands in a Haskell script. A key part of the implementation is the ability to trace commands, using techniques we describe in \S\ref{sec:tracing}. To evaluate our claims, and properly understand the subtlties of our design, we converted existing \Make scripts into \Rattle scripts, and discuss the performance characteristics and \Make script bugs uncovered in \S\ref{sec:evaluation}. Our design can be considered a successor to the \Memoize build system \cite{memoize}, and we compare the differences between that and other related work in \S\ref{sec:related}. Finally, in \S\ref{sec:conclusion} we conclude and describe future work.
